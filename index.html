<!DOCTYPE html>
<html lang="en" dir="ltr">

  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover">

    <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden; /* optional: prevents scrollbars */
    }
    canvas {
      display: block; /* removes inline spacing */
      position: absolute;
      top: 0;
      left: 0;
    }
    </style>
  </head>
<div>

  <ul>
  <div id="dog-image-container" class="canvas">
    <canvas id="canvas" width="900" height="700" class="canvas"></canvas>
    <script >
      // window.addEventListener('DOMContentLoaded', (event) => {
        const squaretable = {} // this section of code is an optimization for use of the hypotenuse function on Line and LineOP objects
        for (let t = 0; t < 10000000; t++) {
            squaretable[`${t}`] = Math.sqrt(t)
            if (t > 999) {
                t += 9
            }
        }
    
        let timerresize = 0
    
        let globlock =0
        let magratmax = 2.5
        let rota = 0
        let rotaspeed = 200
        let magnetonly = -1
        let magnetzoom = -1
        let rotatick = 0
        let rotaclickover = 7
        let rotacounter = 0
        let viewrota = ["r","g","b",'m','p','q','z']
        let magmax = 1
        let magnetism = 1
        let magnetradius = 12
        let magdisplay = 1
        let magmindisp = 0
        let magnetcolors  = ["#00ffff90", "#88888890", "#FFFF0090"]
        let loutmin = 10
        let ringon = 0
        let makeline = 0
        let worldscale = 8
        // let runcount = 10 
        let tempon = 1
        let particletoggle = 1
        let temperatureInvert = 100
        let temperature = 0
        let genelength = 5
        // let codonconstant = Math.min((Math.sqrt(genelength)*1),9)
        let codonconstant = 2 //Math.min((Math.sqrt(genelength)*1),9) //2
        let runcount = 12
        let runsnap = 0
        let ld = 0
          let nodin1 = -1
          let nodin2 = -1
          let start = 0
          let speciesdistance = 70 //75 // 32 was for 3 dimensional color 32 //48 is half
        let signal = 0
        let codonusage = 1
        let repconstant  = 125
        let slide = -1
        let viewStyle = 0
        let headout = 0
        let edgeLoop = -1
        let lasfgl = 0
        let bodc = 0
        let lsstbodc = 0
        let fded  = 0
        let fded2  = 0
        let timesLength = 10 //12
        let mindead = 0
        let driftconstant = 2000 //never set to 0 to get 0 drift set it to like 9999999999999999
        let mutationrate  = .01
        let maxage =750
        let generationConstant =  .6 //(2/3) //.64 precost shift ///.4 works //.59,.6 before codon cost
        let minage = 50
        let fertilityratio = 1.01
        let fertilitycost = .25
        let longevitycost = .25 //nice guess
        if(ringon == 1){
            minage = 1
        }
    
        let makegreen = 0
        let makeall = 0
        // let greens = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]
        let greens = [4]
        let nodecap = 2500
        let video_recorder
        let recording = 0
        let globduper = []
        let predatorIncentive = 0
        let diffdist = -1
        let nodetypes = 16
        let totalKill = 1
        let movementCost = .05 //.5
        let baseCostOfNode = .01 //.01
        let mouthCost  = .04 //.04
        let rotationCost = .02//.02
        let linkcost = .001 // .002
        let linkcostdistance = .0001 
        let genelengthcost = .0001 //.0001
        let magnetcost = .01
        let dragcost = .05
        let pistoncost = .02 //.02
        let anchorcost = .02
        let timemin = 13
    
        let worldscaler =worldscale/8
        // function CanvasCaptureToWEBM(canvas, bitrate) {
        //     // the video_recorder is set to  '= new CanvasCaptureToWEBM(canvas, 4500000);' in the setup, 
        //     // it uses the same canvas as the rest of the file.
        //     // to start a recording call .record() on video_recorder
        //     /*
        //     for example, 
        //     if(keysPressed['-'] && recording == 0){
        //         recording = 1
        //         video_recorder.record()
        //     }
        //     if(keysPressed['='] && recording == 1){
        //         recording = 0
        //         video_recorder.stop()
        //         video_recorder.download('File Name As A String.webm')
        //     }
        //     */
        //     this.record = Record
        //     this.stop = Stop
        //     this.download = saveToDownloads
        //     let blobCaptures = []
        //     let outputFormat = {}
        //     let recorder = {}
        //     let canvasInput = canvas.captureStream()
        //     if (typeof canvasInput == undefined || !canvasInput) {
        //         return
        //     }
        //     const video = document.createElement('video')
        //     video.style.display = 'none'
        
        //     function Record() {
        //         let formats = [
        //             'video/vp8',
        //             "video/webm",
        //             'video/webm,codecs=vp9',
        //             "video/webm\;codecs=vp8",
        //             "video/webm\;codecs=daala",
        //             "video/webm\;codecs=h264",
        //             "video/mpeg"
        //         ];
        
        //         for (let t = 0;t<formats.length;t++) {
        //             if (MediaRecorder.isTypeSupported(formats[t])) {
        //                 outputFormat = formats[t]
        //                 break
        //             }
        //         }
        //         if (typeof outputFormat != "string") {
        //             return
        //         }else{
        //             let videoSettings = {
        //                 mimeType: outputFormat,
        //                 videoBitsPerSecond: bitrate || 2000000 // 2Mbps
        //             };
        //             blobCaptures = []
        //             try {
        //                 recorder = new MediaRecorder(canvasInput, videoSettings)
        //             } catch (error) {
        //                 return;
        //             }
        //             recorder.onstop = handleStop
        //             recorder.ondataavailable = handleAvailableData
        //             recorder.start(100)
        //         } 
        //     }
        //     function handleAvailableData(event) {
        //         if (event.data && event.data.size > 0) {
        //             blobCaptures.push(event.data)
        //         }
        //     }
        //     function handleStop() {
        //         const superBuffer = new Blob(blobCaptures, { type: outputFormat })
        //         video.src = window.URL.createObjectURL(superBuffer)
        //     }
        //     function Stop() {
        //         recorder.stop()
        //         video.controls = true
        //     }
        //     function saveToDownloads(input) { // specifying a file name for the output
        //         const name = input || 'video_out.webm'
        //         const blob = new Blob(blobCaptures, { type: outputFormat })
        //         const url = window.URL.createObjectURL(blob)
        //         const storageElement = document.createElement('a')
        //         storageElement.style.display = 'none'
        //         storageElement.href = url
        //         storageElement.download = name
        //         document.body.appendChild(storageElement)
        //         storageElement.click()
        //         setTimeout(() => {
        //             document.body.removeChild(storageElement)
        //             window.URL.revokeObjectURL(url)
        //         }, 100)
        //     }
        // }
        const gamepadAPI = {
            controller: {},
            turbo: true,
            connect: function(evt) {
                if (navigator.getGamepads()[0] != null) {
                    gamepadAPI.controller = navigator.getGamepads()[0]
                    gamepadAPI.turbo = true;
                } else if (navigator.getGamepads()[1] != null) {
                    gamepadAPI.controller = navigator.getGamepads()[0]
                    gamepadAPI.turbo = true;
                } else if (navigator.getGamepads()[2] != null) {
                    gamepadAPI.controller = navigator.getGamepads()[0]
                    gamepadAPI.turbo = true;
                } else if (navigator.getGamepads()[3] != null) {
                    gamepadAPI.controller = navigator.getGamepads()[0]
                    gamepadAPI.turbo = true;
                }
                for (let i = 0; i < gamepads.length; i++) {
                    if (gamepads[i] === null) {
                        continue;
                    }
                    if (!gamepads[i].connected) {
                        continue;
                    }
                }
            },
            disconnect: function(evt) {
                gamepadAPI.turbo = false;
                delete gamepadAPI.controller;
            },
            update: function() {
                gamepadAPI.controller = navigator.getGamepads()[0]
                gamepadAPI.buttonsCache = []; // clear the buttons cache
                for (var k = 0; k < gamepadAPI.buttonsStatus.length; k++) { // move the buttons status from the previous frame to the cache
                    gamepadAPI.buttonsCache[k] = gamepadAPI.buttonsStatus[k];
                }
                gamepadAPI.buttonsStatus = []; // clear the buttons status
                var c = gamepadAPI.controller || {}; // get the gamepad object
                var pressed = [];
                if (c.buttons) {
                    for (var b = 0, t = c.buttons.length; b < t; b++) { // loop through buttons and push the pressed ones to the array
                        if (c.buttons[b].pressed) {
                            pressed.push(gamepadAPI.buttons[b]);
                        }
                    }
                }
                var axes = [];
                if (c.axes) {
                    for (var a = 0, x = c.axes.length; a < x; a++) { // loop through axes and push their values to the array
                        axes.push(c.axes[a].toFixed(2));
                    }
                }
                gamepadAPI.axesStatus = axes; // assign received values
                gamepadAPI.buttonsStatus = pressed;
                // //////////////////////////console.log(pressed); // return buttons for debugging purposes
                return pressed;
            },
            buttonPressed: function(button, hold) {
                var newPress = false;
                for (var i = 0, s = gamepadAPI.buttonsStatus.length; i < s; i++) { // loop through pressed buttons
                    if (gamepadAPI.buttonsStatus[i] == button) { // if we found the button we're looking for...
                        newPress = true; // set the boolean variable to true
                        if (!hold) { // if we want to check the single press
                            for (var j = 0, p = gamepadAPI.buttonsCache.length; j < p; j++) { // loop through the cached states from the previous frame
                                if (gamepadAPI.buttonsCache[j] == button) { // if the button was already pressed, ignore new press
                                    newPress = false;
                                }
                            }
                        }
                    }
                }
                return newPress;
            },
            buttons: [
                'A', 'B', 'X', 'Y', 'LB', 'RB', 'Left-Trigger', 'Right-Trigger', 'Back', 'Start', 'Axis-Left', 'Axis-Right', 'DPad-Up', 'DPad-Down', 'DPad-Left', 'DPad-Right', "Power"
            ],
            buttonsCache: [],
            buttonsStatus: [],
            axesStatus: []
        };
        let canvas
        let canvas_context
        let keysPressed = {}
        let FLEX_engine
        let TIP_engine = {}
        let XS_engine
        let YS_engine
        //(2).valueOf() 
        //2
        class Point {
            constructor(x, y) {
                this.x = x
                this.y = y
                this.radius = 0
            }
            pointDistance(point) {
                return (new LineOP(this, point, "transparent", 0)).hypotenuse()
            }
        }
        
        class Vector { // vector math and physics if you prefer this over vector components on circles
            constructor(object = (new Point(0, 0)), xmom = 0, ymom = 0) {
                this.xmom = xmom
                this.ymom = ymom
                this.object = object
            }
            isToward(point) {
                let link = new LineOP(this.object, point)
                let dis1 = link.squareDistance()
                let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                let link2 = new LineOP(dummy, point)
                let dis2 = link2.squareDistance()
                if (dis2 < dis1) {
                    return true
                } else {
                    return false
                }
            }
            rotate(angleGoal) {
                let link = new Line(this.xmom, this.ymom, 0, 0)
                let length = link.hypotenuse()
                let x = (length * Math.cos(angleGoal))
                let y = (length * Math.sin(angleGoal))
                this.xmom = x
                this.ymom = y
            }
            magnitude() {
                return (new Line(this.xmom, this.ymom, 0, 0)).hypotenuse()
            }
            normalize(size = 1) {
                let magnitude = this.magnitude()
                this.xmom /= magnitude
                this.ymom /= magnitude
                this.xmom *= size
                this.ymom *= size
            }
            multiply(vect) {
                let point = new Point(0, 0)
                let end = new Point(this.xmom + vect.xmom, this.ymom + vect.ymom)
                return point.pointDistance(end)
            }
            add(vect) {
                return new Vector(this.object, this.xmom + vect.xmom, this.ymom + vect.ymom)
            }
            subtract(vect) {
                return new Vector(this.object, this.xmom - vect.xmom, this.ymom - vect.ymom)
            }
            divide(vect) {
                return new Vector(this.object, this.xmom / vect.xmom, this.ymom / vect.ymom) //be careful with this, I don't think this is right
            }
            draw() {
                let dummy = new Point(this.object.x + this.xmom, this.object.y + this.ymom)
                let link = new LineOP(this.object, dummy, "#FFFFFF", 1)
                link.draw()
            }
        }
        class Line {
            constructor(x, y, x2, y2, color, width) {
                this.x1 = x
                this.y1 = y
                this.x2 = x2
                this.y2 = y2
                this.color = color
                this.width = width
            }
            angle() {
                return Math.atan2(this.y1 - this.y2, this.x1 - this.x2)
            }
            squareDistance() {
                let xdif = this.x1 - this.x2
                let ydif = this.y1 - this.y2
                let squareDistance = (xdif * xdif) + (ydif * ydif)
                return squareDistance
            }
            hypotenuse() {
                let xdif = this.x1 - this.x2
                let ydif = this.y1 - this.y2
                let hypotenuse = (xdif * xdif) + (ydif * ydif)
                if (hypotenuse < 10000000 - 1) {
                    if (hypotenuse > 1000) {
                        return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
                    } else {
                        return squaretable[`${Math.round(hypotenuse)}`]
                    }
                } else {
                    return Math.sqrt(hypotenuse)
                }
            }
            draw() {
                let lineWidthstorage = canvas_context.lineWidth
                canvas_context.strokeStyle = this.color
                canvas_context.lineWidth = this.width
                canvas_context.beginPath()
                canvas_context.moveTo(this.x1, this.y1)
                canvas_context.lineTo(this.x2, this.y2)
                canvas_context.stroke()
                canvas_context.lineWidth = lineWidthstorage
            }
        }
        class LineOP {
            constructor(object, target, color, width) {
                this.object = object
                this.target = target
                this.color = color
                this.width = width
            }
            squareDistance() {
                let xdif = this.object.x - this.target.x
                let ydif = this.object.y - this.target.y
                let squareDistance = (xdif * xdif) + (ydif * ydif)
                return squareDistance
            }
            hypotenuse() {
                if(this.target.dead == 1 || this.object.dead == 1){
                    return 999999999999
                }
                let xdif = this.object.x - this.target.x
                let ydif = this.object.y - this.target.y
                let hypotenuse = (xdif * xdif) + (ydif * ydif)
                if (hypotenuse < 10000000 - 1) {
                    if (hypotenuse > 1000) {
                        return squaretable[`${Math.round(10 * Math.round((hypotenuse * .1)))}`]
                    } else {
                        return squaretable[`${Math.round(hypotenuse)}`]
                    }
                } else {
                    return Math.sqrt(hypotenuse)
                }
            }
            angle() {
                return Math.atan2(this.object.y - this.target.y, this.object.x - this.target.x)
            }
    
            draw() {
                let worldscaler = (worldscale/8)
                if(viewStyle ==3){
                    return
                }
                ld++
                let lineWidthstorage = canvas_context.lineWidth
                canvas_context.strokeStyle = this.color
    
                canvas_context.lineWidth = this.width
                if(viewStyle == 1){
    
                    canvas_context.lineWidth = 8*(worldscaler)
                let grad = canvas_context.createRadialGradient(this.object.x, this.object.y, 0, this.object.x, this.object.y, this.hypotenuse()*1);
                grad.addColorStop(0, nodecolors[this.object.type])
                grad.addColorStop(.10, nodecolors[this.object.type])
                grad.addColorStop(.90, nodecolors[this.target.type])
                grad.addColorStop(1, nodecolors[this.target.type])
                canvas_context.strokeStyle = grad
                }
                if(viewStyle == 2){
    
                    canvas_context.lineWidth = 1*(worldscaler)
                let grad = canvas_context.createRadialGradient(this.object.x, this.object.y, 0, this.object.x, this.object.y, this.hypotenuse()*1);
                grad.addColorStop(0, nodecolors[this.object.type]+"88")
                grad.addColorStop(.10, nodecolors[this.object.type]+"88")
                grad.addColorStop(.90, nodecolors[this.target.type]+"88")
                grad.addColorStop(1, nodecolors[this.target.type]+"88")
                canvas_context.strokeStyle = grad
                }
                if(viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7){
    
                    canvas_context.lineWidth = 8*(worldscaler)
                let grad = canvas_context.createRadialGradient(this.object.x, this.object.y, 0, this.object.x, this.object.y, this.hypotenuse()*1);
                grad.addColorStop(0, this.object.parent.subcolor)
                grad.addColorStop(1, this.target.parent.subcolor)
                canvas_context.strokeStyle = grad
                }
                canvas_context.beginPath()
                canvas_context.moveTo(this.object.x, this.object.y)
                canvas_context.lineTo(this.target.x, this.target.y)
                canvas_context.stroke()
                canvas_context.lineWidth = lineWidthstorage
            }
        }
        class Triangle {
            constructor(x, y, color, length, fill = 0, strokeWidth = 0, leg1Ratio = 1, leg2Ratio = 1, heightRatio = 1) {
                this.x = x
                this.y = y
                this.color = color
                this.length = length
                this.x1 = this.x + this.length * leg1Ratio
                this.x2 = this.x - this.length * leg2Ratio
                this.tip = this.y - this.length * heightRatio
                this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                this.fill = fill
                this.stroke = strokeWidth
            }
            draw() {
                canvas_context.strokeStyle = this.color
                canvas_context.stokeWidth = this.stroke
                canvas_context.beginPath()
                canvas_context.moveTo(this.x, this.y)
                canvas_context.lineTo(this.x1, this.y)
                canvas_context.lineTo(this.x, this.tip)
                canvas_context.lineTo(this.x2, this.y)
                canvas_context.lineTo(this.x, this.y)
                if (this.fill == 1) {
                    canvas_context.fill()
                }
                canvas_context.stroke()
                canvas_context.closePath()
            }
            isPointInside(point) {
                if (point.x <= this.x1) {
                    if (point.y >= this.tip) {
                        if (point.y <= this.y) {
                            if (point.x >= this.x2) {
                                this.accept1 = (this.y - this.tip) / (this.x1 - this.x)
                                this.accept2 = (this.y - this.tip) / (this.x2 - this.x)
                                this.basey = point.y - this.tip
                                this.basex = point.x - this.x
                                if (this.basex == 0) {
                                    return true
                                }
                                this.slope = this.basey / this.basex
                                if (this.slope >= this.accept1) {
                                    return true
                                } else if (this.slope <= this.accept2) {
                                    return true
                                }
                            }
                        }
                    }
                }
                return false
            }
        }
        class Rectangle {
            constructor(x, y, width, height, color, fill = 1, stroke = 0, strokeWidth = 1) {
                this.x = x
                this.y = y
                this.height = height
                this.width = width
                this.color = color
                this.xmom = 0
                this.ymom = 0
                this.stroke = stroke
                this.strokeWidth = strokeWidth
                this.fill = fill
            }
            draw() {
                canvas_context.strokeStyle = this.color
                canvas_context.lineWidth = 1
                canvas_context.strokeRect(this.x, this.y, this.width, this.height)
            }
            fill() {
                canvas_context.fillStyle = this.color
                canvas_context.lineWidth = 1
                canvas_context.fillRect(this.x, this.y, this.width, this.height)
            }
            move() {
                this.x += this.xmom
                this.y += this.ymom
            }
            isPointInside(point) {
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
                                return true
                            }
                        }
                    }
                }
                return false
            }
            doesPerimeterTouch(point) {
                if (point.x + point.radius >= this.x) {
                    if (point.y + point.radius >= this.y) {
                        if (point.x - point.radius <= this.x + this.width) {
                            if (point.y - point.radius <= this.y + this.height) {
                                return true
                            }
                        }
                    }
                }
                return false
            }
        }
        class Circle {
            constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                this.x = x
                this.y = y
                this.radius = radius
                this.color = color
                this.xmom = xmom
                this.ymom = ymom
                this.friction = friction
                this.reflect = reflect
                this.strokeWidth = strokeWidth
                this.strokeColor = strokeColor
            }
      
            draw() {
                let worldscaler = worldscale/8
                if(viewStyle ==3){
                    return
                }
                canvas_context.lineWidth = 2*worldscaler
                canvas_context.strokeStyle = this.color
                canvas_context.beginPath();
                if (this.radius > 0) {
                    if(viewStyle == 2){
    
                let grad = canvas_context.createRadialGradient(this.x, this.y, 0, this.x, this.y, 10);
                grad.addColorStop(0, nodecolors[this.type])
                grad.addColorStop(1, "#00000000") 
                canvas_context.fillStyle = grad
                if(this.shrink != 1){
                        
                    this.radius = 10*(worldscaler)
    
                }
                    canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                    // canvas_context.fillStyle = this.color
                    canvas_context.fill()
    
    
    
                    }else{
    
                    if(viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7){
    
                        if(this.shrink != 1){
                        this.radius = 4*(worldscaler)
                        }
                    }
                    canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
                    canvas_context.fillStyle = this.color
                    if(viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7){
                        canvas_context.fillStyle = this.subcolor
                    }
                    if(viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7){
                    canvas_context.fill()
    
                    }else{
    
                    canvas_context.stroke();
                    }
                    }
                } else {
                    ////////console.l\og("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                }
            }
            move() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x += this.xmom
                this.y += this.ymom
            }
            unmove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x -= this.xmom
                this.y -= this.ymom
            }
            frictiveMove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x += this.xmom
                this.y += this.ymom
                this.xmom *= this.friction
                this.ymom *= this.friction
            }
            frictiveunMove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.xmom /= this.friction
                this.ymom /= this.friction
                this.x -= this.xmom
                this.y -= this.ymom
            }
            isPointInside(point) {
                this.areaY = point.y - this.y
                this.areaX = point.x - this.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                    return true
                }
                return false
            }
            doesPerimeterTouch(point) {
                this.areaY = point.y - this.y
                this.areaX = point.x - this.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                    return true
                }
                return false
            }
        }
        class CircleFill {
            constructor(x, y, radius, color, xmom = 0, ymom = 0, friction = 1, reflect = 0, strokeWidth = 0, strokeColor = "transparent") {
                this.x = x
                this.y = y
                this.radius = radius
                this.color = color
                this.xmom = xmom
                this.ymom = ymom
                this.friction = friction
                this.reflect = reflect
                this.strokeWidth = strokeWidth
                this.strokeColor = strokeColor
            }
      
            draw() {
                canvas_context.lineWidth = 2
                canvas_context.strokeStyle = this.color
                canvas_context.beginPath();
                if (this.radius > 0) {
                    canvas_context.arc(this.x, this.y, this.radius, 0, (Math.PI * 2), true)
    
                let grad = canvas_context.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius*1.5);
    
                grad.addColorStop(0, this.color)
                grad.addColorStop(1, "#00000000")
                    canvas_context.fillStyle = grad
                    // canvas_context.stroke();
                    canvas_context.fill();
                    
                    
                } else {
                    ////////console.l\og("The circle is below a radius of 0, and has not been drawn. The circle is:", this)
                }
            }
            move() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x += this.xmom
                this.y += this.ymom
            }
            unmove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x -= this.xmom
                this.y -= this.ymom
            }
            frictiveMove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.x += this.xmom
                this.y += this.ymom
                this.xmom *= this.friction
                this.ymom *= this.friction
            }
            frictiveunMove() {
                if (this.reflect == 1) {
                    if (this.x + this.radius > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y + this.radius > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.x - this.radius < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.y - this.radius < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.xmom /= this.friction
                this.ymom /= this.friction
                this.x -= this.xmom
                this.y -= this.ymom
            }
            isPointInside(point) {
                this.areaY = point.y - this.y
                this.areaX = point.x - this.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.radius * this.radius)) {
                    return true
                }
                return false
            }
            doesPerimeterTouch(point) {
                this.areaY = point.y - this.y
                this.areaX = point.x - this.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= ((this.radius + point.radius) * (this.radius + point.radius))) {
                    return true
                }
                return false
            }
        }
        class Polygon {
            constructor(x, y, size, color, sides = 3, xmom = 0, ymom = 0, angle = 0, reflect = 0) {
                if (sides < 2) {
                    sides = 2
                }
                this.reflect = reflect
                this.xmom = xmom
                this.ymom = ymom
                this.body = new Circle(x, y, size - (size * .293), "transparent")
                this.nodes = []
                this.angle = angle
                this.size = size
                this.color = color
                this.angleIncrement = (Math.PI * 2) / sides
                this.sides = sides
                for (let t = 0; t < sides; t++) {
                    let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                    this.nodes.push(node)
                    this.angle += this.angleIncrement
                }
            }
            isPointInside(point) { // rough approximation
                this.body.radius = this.size - (this.size * .293)
                if (this.sides <= 2) {
                    return false
                }
                this.areaY = point.y - this.body.y
                this.areaX = point.x - this.body.x
                if (((this.areaX * this.areaX) + (this.areaY * this.areaY)) <= (this.body.radius * this.body.radius)) {
                    return true
                }
                return false
            }
            move() {
                if (this.reflect == 1) {
                    if (this.body.x > canvas.width) {
                        if (this.xmom > 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.body.y > canvas.height) {
                        if (this.ymom > 0) {
                            this.ymom *= -1
                        }
                    }
                    if (this.body.x < 0) {
                        if (this.xmom < 0) {
                            this.xmom *= -1
                        }
                    }
                    if (this.body.y < 0) {
                        if (this.ymom < 0) {
                            this.ymom *= -1
                        }
                    }
                }
                this.body.x += this.xmom
                this.body.y += this.ymom
            }
    
            draw() {
                if(viewStyle ==3){
                    return
                }
    
                if(viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7){
                    this.body.subcolor = this.parent.subcolor
                    this.body.radius = 2*(worldscaler)
                    this.body.type = this.type
                    this.body.draw()
                    return
                }
    
                if(viewStyle == 1 || viewStyle == 2){
                    this.body.color = nodecolors[this.type]
                    this.body.radius = 2*(worldscaler)
                    this.body.type = this.type
                    this.body.draw()
                    return
                }
                this.angleIncrement = (Math.PI * 2) / this.sides
                this.body.radius = this.size - (this.size * .293)
                if(this.first != 1){
                    if(this.sides ==2){
                        this.angleIncrement*.5
                        this.nodes = []
                        for (let t = 0; t < this.sides*2; t++) {
                            let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                            this.nodes.push(node)
                            this.angle += this.angleIncrement
                        }
                        this.first = 1
                    }else{
    
                    this.nodes = []
                    for (let t = 0; t < this.sides; t++) {
                        let node = new Circle(this.body.x + (this.size * (Math.cos(this.angle))), this.body.y + (this.size * (Math.sin(this.angle))), 0, "transparent")
                        this.nodes.push(node)
                        this.angle += this.angleIncrement
                    }
                    this.first = 1
                    }
    
                }else{
    
                    if(this.sides ==2){
    
                    }else{
    
                        for (let t = 0; t < this.sides; t++) {
                            this.nodes[t].x = this.body.x + (this.size * (Math.cos(this.angle)))
                            this.nodes[t].y = this.body.y + (this.size * (Math.sin(this.angle)))
                            this.angle += this.angleIncrement
                        }
                    }
                    
                }
    
                
                if(this.sides == 2){
    
                    if(this.done != 1){
    
                        let d = new X(this.body.x, this.body.y, this.color, this.size, this.angle)
                        this.xd = d
                        this.done = 1
                        this.xd.draw(this.angle)
                    }else{
    
                        this.xd.x = this.body.x
                        this.xd.y = this.body.y
                        this.xd.draw(this.angle) 
                    }
                }else{
    
                canvas_context.beginPath()
                canvas_context.moveTo(this.nodes[0].x, this.nodes[0].y)
                for (let t = 1; t < this.nodes.length; t++) {
                    canvas_context.lineTo(this.nodes[t].x, this.nodes[t].y)
                }
                canvas_context.closePath()
                }
                // canvas_context.lineTo(this.nodes[0].x, this.nodes[0].y)
                // canvas_context.fill()
                canvas_context.strokeStyle = this.color
                canvas_context.fillStyle = this.color
                canvas_context.lineWidth = Math.max(2*worldscaler,1)
                canvas_context.stroke()
            }
        }
        class Shape {
            constructor(shapes) {
                this.shapes = shapes
            }
            draw() {
                for (let t = 0; t < this.shapes.length; t++) {
                    this.shapes[t].draw()
                }
            }
            isPointInside(point) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (this.shapes[t].isPointInside(point)) {
                        return true
                    }
                }
                return false
            }
            doesPerimeterTouch(point) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (this.shapes[t].doesPerimeterTouch(point)) {
                        return true
                    }
                }
                return false
            }
            innerShape(point) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (this.shapes[t].doesPerimeterTouch(point)) {
                        return this.shapes[t]
                    }
                }
                return false
            }
            isInsideOf(box) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (box.isPointInside(this.shapes[t])) {
                        return true
                    }
                }
                return false
            }
            adjustByFromDisplacement(x, y) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (typeof this.shapes[t].fromRatio == "number") {
                        this.shapes[t].x += x * this.shapes[t].fromRatio
                        this.shapes[t].y += y * this.shapes[t].fromRatio
                    }
                }
            }
            adjustByToDisplacement(x, y) {
                for (let t = 0; t < this.shapes.length; t++) {
                    if (typeof this.shapes[t].toRatio == "number") {
                        this.shapes[t].x += x * this.shapes[t].toRatio
                        this.shapes[t].y += y * this.shapes[t].toRatio
                    }
                }
            }
            mixIn(arr) {
                for (let t = 0; t < arr.length; t++) {
                    for (let k = 0; k < arr[t].shapes.length; k++) {
                        this.shapes.push(arr[t].shapes[k])
                    }
                }
            }
            push(object) {
                this.shapes.push(object)
            }
        }
        
        class Spring {
            constructor(x, y, radius, color, body = 0, length = 1, gravity = 0, width = 1) {
                if (body == 0) {
                    this.body = new Circle(x, y, radius, color)
                    this.anchor = new Circle(x, y, radius, color)
                    this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                    this.length = length
                } else {
                    this.body = body
                    this.anchor = new Circle(x, y, radius, color)
                    this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", width)
                    this.length = length
                }
                this.gravity = gravity
                this.width = width
            }
            balance() {
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                if (this.beam.hypotenuse() < this.length) {
                    this.body.xmom += (this.body.x - this.anchor.x) / this.length
                    this.body.ymom += (this.body.y - this.anchor.y) / this.length
                    this.anchor.xmom -= (this.body.x - this.anchor.x) / this.length
                    this.anchor.ymom -= (this.body.y - this.anchor.y) / this.length
                } else {
                    this.body.xmom -= (this.body.x - this.anchor.x) / this.length
                    this.body.ymom -= (this.body.y - this.anchor.y) / this.length
                    this.anchor.xmom += (this.body.x - this.anchor.x) / this.length
                    this.anchor.ymom += (this.body.y - this.anchor.y) / this.length
                }
                let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
            }
            draw() {
                this.beam = new Line(this.body.x, this.body.y, this.anchor.x, this.anchor.y, "yellow", this.width)
                this.beam.draw()
                this.body.draw()
                this.anchor.draw()
            }
            move() {
                this.anchor.ymom += this.gravity
                this.anchor.move()
            }
        
        }
        class SpringOP {
            constructor(body, anchor, length, width = 3, color = body.color) {
                this.body = body
                this.anchor = anchor
                this.beam = new LineOP(body, anchor, color, width)
                this.length = length
            }
            balance() {
                if (this.beam.hypotenuse() < this.length) {
                    this.body.xmom += ((this.body.x - this.anchor.x) / this.length)
                    this.body.ymom += ((this.body.y - this.anchor.y) / this.length)
                    this.anchor.xmom -= ((this.body.x - this.anchor.x) / this.length)
                    this.anchor.ymom -= ((this.body.y - this.anchor.y) / this.length)
                } else if (this.beam.hypotenuse() > this.length) {
                    this.body.xmom -= (this.body.x - this.anchor.x) / (this.length)
                    this.body.ymom -= (this.body.y - this.anchor.y) / (this.length)
                    this.anchor.xmom += (this.body.x - this.anchor.x) / (this.length)
                    this.anchor.ymom += (this.body.y - this.anchor.y) / (this.length)
                }
        
                let xmomentumaverage = (this.body.xmom + this.anchor.xmom) / 2
                let ymomentumaverage = (this.body.ymom + this.anchor.ymom) / 2
                this.body.xmom = (this.body.xmom + xmomentumaverage) / 2
                this.body.ymom = (this.body.ymom + ymomentumaverage) / 2
                this.anchor.xmom = (this.anchor.xmom + xmomentumaverage) / 2
                this.anchor.ymom = (this.anchor.ymom + ymomentumaverage) / 2
            }
            draw() {
                this.beam.draw()
            }
            move() {
                //movement of SpringOP objects should be handled separate from their linkage, to allow for many connections, balance here with this object, move nodes independently
            }
        }
        
        class Color {
            constructor(baseColor, red = -1, green = -1, blue = -1, alpha = 1) {
                this.hue = baseColor
                if (red != -1 && green != -1 && blue != -1) {
                    this.r = red
                    this.g = green
                    this.b = blue
                    if (alpha != 1) {
                        if (alpha < 1) {
                            this.alpha = alpha
                        } else {
                            this.alpha = alpha / 255
                            if (this.alpha > 1) {
                                this.alpha = 1
                            }
                        }
                    }
                    if (this.r > 255) {
                        this.r = 255
                    }
                    if (this.g > 255) {
                        this.g = 255
                    }
                    if (this.b > 255) {
                        this.b = 255
                    }
                    if (this.r < 0) {
                        this.r = 0
                    }
                    if (this.g < 0) {
                        this.g = 0
                    }
                    if (this.b < 0) {
                        this.b = 0
                    }
                } else {
                    this.r = 0
                    this.g = 0
                    this.b = 0
                }
            }
            normalize() {
                if (this.r > 255) {
                    this.r = 255
                }
                if (this.g > 255) {
                    this.g = 255
                }
                if (this.b > 255) {
                    this.b = 255
                }
                if (this.r < 0) {
                    this.r = 0
                }
                if (this.g < 0) {
                    this.g = 0
                }
                if (this.b < 0) {
                    this.b = 0
                }
            }
            randomLight() {
                var letters = '0123456789ABCDEF';
                var hash = '#';
                for (var i = 0; i < 6; i++) {
                    hash += letters[(Math.floor(Math.random() * 12) + 4)];
                }
                var color = new Color(hash, 55 + Math.random() * 200, 55 + Math.random() * 200, 55 + Math.random() * 200)
                return color;
            }
            randomDark() {
                var letters = '0123456789ABCDEF';
                var hash = '#';
                for (var i = 0; i < 6; i++) {
                    hash += letters[(Math.floor(Math.random() * 12))];
                }
                var color = new Color(hash, Math.random() * 200, Math.random() * 200, Math.random() * 200)
                return color;
            }
            random() {
                var letters = '0123456789ABCDEF';
                var hash = '#';
                for (var i = 0; i < 6; i++) {
                    hash += letters[(Math.floor(Math.random() * 16))];
                }
                var color = new Color(hash, Math.random() * 255, Math.random() * 255, Math.random() * 255)
                return color;
            }
        }
        class Softbody { //buggy, spins in place
            constructor(x, y, radius, color, members = 10, memberLength = 5, force = 10, gravity = 0) {
                this.springs = []
                this.pin = new Circle(x, y, radius, color)
                this.spring = new Spring(x, y, radius, color, this.pin, memberLength, gravity)
                this.springs.push(this.spring)
                for (let k = 0; k < members; k++) {
                    this.spring = new Spring(x, y, radius, color, this.spring.anchor, memberLength, gravity)
                    if (k < members - 1) {
                        this.springs.push(this.spring)
                    } else {
                        this.spring.anchor = this.pin
                        this.springs.push(this.spring)
                    }
                }
                this.forceConstant = force
                this.centroid = new Point(0, 0)
            }
            circularize() {
                this.xpoint = 0
                this.ypoint = 0
                for (let s = 0; s < this.springs.length; s++) {
                    this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                    this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                }
                this.centroid.x = this.xpoint
                this.centroid.y = this.ypoint
                this.angle = 0
                this.angleIncrement = (Math.PI * 2) / this.springs.length
                for (let t = 0; t < this.springs.length; t++) {
                    this.springs[t].body.x = this.centroid.x + (Math.cos(this.angle) * this.forceConstant)
                    this.springs[t].body.y = this.centroid.y + (Math.sin(this.angle) * this.forceConstant)
                    this.angle += this.angleIncrement
                }
            }
            balance() {
                for (let s = this.springs.length - 1; s >= 0; s--) {
                    this.springs[s].balance()
                }
                this.xpoint = 0
                this.ypoint = 0
                for (let s = 0; s < this.springs.length; s++) {
                    this.xpoint += (this.springs[s].anchor.x / this.springs.length)
                    this.ypoint += (this.springs[s].anchor.y / this.springs.length)
                }
                this.centroid.x = this.xpoint
                this.centroid.y = this.ypoint
                for (let s = 0; s < this.springs.length; s++) {
                    this.link = new Line(this.centroid.x, this.centroid.y, this.springs[s].anchor.x, this.springs[s].anchor.y, 0, "transparent")
                    if (this.link.hypotenuse() != 0) {
                        this.springs[s].anchor.xmom += (((this.springs[s].anchor.x - this.centroid.x) / (this.link.hypotenuse()))) * this.forceConstant
                        this.springs[s].anchor.ymom += (((this.springs[s].anchor.y - this.centroid.y) / (this.link.hypotenuse()))) * this.forceConstant
                    }
                }
                for (let s = 0; s < this.springs.length; s++) {
                    this.springs[s].move()
                }
                for (let s = 0; s < this.springs.length; s++) {
                    this.springs[s].draw()
                }
            }
        }
        class Observer {
            constructor(x, y, radius, color, range = 100, rays = 10, angle = (Math.PI * .125)) {
                this.body = new Circle(x, y, radius, color)
                this.color = color
                this.ray = []
                this.rayrange = range
                this.globalangle = Math.PI
                this.gapangle = angle
                this.currentangle = 0
                this.obstacles = []
                this.raymake = rays
            }
            beam() {
                this.currentangle = this.gapangle / 2
                for (let k = 0; k < this.raymake; k++) {
                    this.currentangle += (this.gapangle / Math.ceil(this.raymake / 2))
                    let ray = new Circle(this.body.x, this.body.y, 1, "white", (((Math.cos(this.globalangle + this.currentangle)))), (((Math.sin(this.globalangle + this.currentangle)))))
                    ray.collided = 0
                    ray.lifespan = this.rayrange - 1
                    this.ray.push(ray)
                }
                for (let f = 0; f < this.rayrange; f++) {
                    for (let t = 0; t < this.ray.length; t++) {
                        if (this.ray[t].collided < 1) {
                            this.ray[t].move()
                            for (let q = 0; q < this.obstacles.length; q++) {
                                if (this.obstacles[q].isPointInside(this.ray[t])) {
                                    this.ray[t].collided = 1
                                }
                            }
                        }
                    }
                }
            }
            draw() {
                this.beam()
                this.body.draw()
                canvas_context.lineWidth = 1
                canvas_context.fillStyle = this.color
                canvas_context.strokeStyle = this.color
                canvas_context.beginPath()
                canvas_context.moveTo(this.body.x, this.body.y)
                for (let y = 0; y < this.ray.length; y++) {
                    canvas_context.lineTo(this.ray[y].x, this.ray[y].y)
                    canvas_context.lineTo(this.body.x, this.body.y)
                }
                canvas_context.stroke()
                canvas_context.fill()
                this.ray = []
            }
        }
        
        function setUp(canvas_pass, style = "#000000") {
            canvas = canvas_pass
            // video_recorder = new CanvasCaptureToWEBM(canvas, 4500000);
            canvas_context = canvas.getContext('2d');
            canvas.style.background = style
            window.setInterval(function() {
                runsnap++
                if(keysPressed['m']){
                    magdisplay *= -1
    
                keysPressed['m'] = false
                }
                if(keysPressed['o']){
                    runcount--
                    if(runcount <= 1){
                        runcount = 1
                    }
                }
                if(keysPressed['i']){
    
                    runcount = 10
                }
                if(keysPressed[' ']){
    
                    // runcount = 10000000000000 
                }
                if(runsnap%runcount == 0){
                    if(keysPressed['p']){
                        runcount++
                        if(runcount >= 1000){
                            runcount = 1000
                        }
                    }
    
            // if(keysPressed['-'] && recording == 0){
            //     recording = 1
            //     video_recorder.record()
            // }
            // if(keysPressed['='] && recording == 1){
            //     recording = 0
            //     video_recorder.stop()
            //     video_recorder.download('Inochi.webm')
            // }
                    main()
                }
            }, 1)
            document.addEventListener('keydown', (event) => {
                keysPressed[event.key] = true;
            });
            document.addEventListener('keyup', (event) => {
                delete keysPressed[event.key];
            });
            window.addEventListener('pointerdown', e => {
                FLEX_engine = canvas.getBoundingClientRect();
                XS_engine = e.clientX - FLEX_engine.left;
                YS_engine = e.clientY - FLEX_engine.top;
                TIP_engine.x = XS_engine
                TIP_engine.y = YS_engine
                TIP_engine.body = TIP_engine
                // organeo.genes[0].body.x += 10
                if(start == 0){
                    UI.check(TIP_engine)
                }
                // example usage: if(object.isPointInside(TIP_engine)){ take action }
            window.addEventListener('pointermove', stupidcontinued_stimuli);
            });
    
            window.addEventListener('pointermove', continued_stimuli);
            window.addEventListener('pointerup', e => {
                window.removeEventListener("pointermove", stupidcontinued_stimuli);
            })
        
            function continued_stimuli(e) {
                FLEX_engine = canvas.getBoundingClientRect();
                XS_engine = e.clientX - FLEX_engine.left;
                YS_engine = e.clientY - FLEX_engine.top;
                TIP_engine.x = XS_engine
                TIP_engine.y = YS_engine
                TIP_engine.body = TIP_engine
    
    
            }
            function stupidcontinued_stimuli(e) {
                FLEX_engine = canvas.getBoundingClientRect();
                XS_engine = e.clientX - FLEX_engine.left;
                YS_engine = e.clientY - FLEX_engine.top;
                TIP_engine.x = XS_engine
                TIP_engine.y = YS_engine
                TIP_engine.body = TIP_engine
                if(start == 0){
                    UI.stupidCheck(TIP_engine)
                }
            }
        }
        
        function gamepad_control(object, speed = 1) { // basic control for objects using the controler
            //         ////////console.l\og(gamepadAPI.axesStatus[1]*gamepadAPI.axesStatus[0]) //debugging
            if (typeof object.body != 'undefined') {
                if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                    if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                        object.body.x += (gamepadAPI.axesStatus[0] * speed)
                        object.body.y += (gamepadAPI.axesStatus[1] * speed)
                    }
                }
            } else if (typeof object != 'undefined') {
                if (typeof(gamepadAPI.axesStatus[1]) != 'undefined') {
                    if (typeof(gamepadAPI.axesStatus[0]) != 'undefined') {
                        object.x += (gamepadAPI.axesStatus[0] * speed)
                        object.y += (gamepadAPI.axesStatus[1] * speed)
                    }
                }
            }
        }
        
        function control(object, speed = 1) { // basic control for objects
            if (typeof object.body != 'undefined') {
                if (keysPressed['w']) {
                    object.body.y -= speed
                }
                if (keysPressed['d']) {
                    object.body.x += speed
                }
                if (keysPressed['s']) {
                    object.body.y += speed
                }
                if (keysPressed['a']) {
                    object.body.x -= speed
                }
            } else if (typeof object != 'undefined') {
                if (keysPressed['w']) {
                    object.y -= speed
                }
                if (keysPressed['d']) {
                    object.x += speed
                }
                if (keysPressed['s']) {
                    object.y += speed
                }
                if (keysPressed['a']) {
                    object.x -= speed
                }
            }
        }
        
        function getRandomLightColor() { // random color that will be visible on  black background
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[(Math.floor(Math.random() * 12) + 4)];
            }
            return color;
        }
        
        function getRandomColor() { // random color
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[(Math.floor(Math.random() * 16) + 0)];
            }
            return color;
        }
        
        function getRandomDarkColor() { // color that will be visible on a black background
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[(Math.floor(Math.random() * 12))];
            }
            return color;
        }
        
        function castBetween(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
            let limit = granularity
            let shape_array = []
            for (let t = 0; t < limit; t++) {
                let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
                circ.toRatio = t / limit
                circ.fromRatio = (limit - t) / limit
                shape_array.push(circ)
            }
            return (new Shape(shape_array))
        }
        
        function castBetweenPoints(from, to, granularity = 10, radius = 1) { //creates a sort of beam hitbox between two points, with a granularity (number of members over distance), with a radius defined as well
            let limit = granularity
            let shape_array = []
            for (let t = 0; t < limit; t++) {
                let circ = new Circle((from.x * (t / limit)) + (to.x * ((limit - t) / limit)), (from.y * (t / limit)) + (to.y * ((limit - t) / limit)), radius, "red")
                circ.toRatio = t / limit
                circ.fromRatio = (limit - t) / limit
                shape_array.push(circ)
            }
            return shape_array
        }
        
        class Disang {
            constructor(dis, ang) {
                this.dis = dis
                this.angle = ang
            }
        }
        
        class BezierHitbox {
            constructor(x, y, cx, cy, ex, ey, color = "red") { // this function takes a starting x,y, a control point x,y, and a end point x,y
                this.color = color
                this.x = x
                this.y = y
                this.cx = cx
                this.cy = cy
                this.ex = ex
                this.ey = ey
                this.metapoint = new Circle((x + cx + ex) / 3, (y + cy + ey) / 3, 3, "#FFFFFF")
                this.granularity = 100
                this.body = [...castBetweenPoints((new Point(this.x, this.y)), (new Point(this.ex, this.ey)), this.granularity, 0)]
        
                let angle = (new Line(this.x, this.y, this.ex, this.ey)).angle()
        
                this.angles = []
                for (let t = 0; t < this.granularity; t++) {
                    this.angles.push(angle)
                }
                for (let t = 0; t <= 1; t += 1 / this.granularity) {
                    this.body.push(this.getQuadraticXY(t))
                    this.angles.push(this.getQuadraticAngle(t))
                }
                this.hitbox = []
                for (let t = 0; t < this.body.length; t++) {
                    let link = new LineOP(this.body[t], this.metapoint)
                    let disang = new Disang(link.hypotenuse(), link.angle() + (Math.PI * 2))
                    this.hitbox.push(disang)
                }
                this.constructed = 1
            }
            isPointInside(point) {
                let link = new LineOP(point, this.metapoint)
                let angle = (link.angle() + (Math.PI * 2))
                let dis = link.hypotenuse()
                for (let t = 1; t < this.hitbox.length; t++) {
                    if (Math.abs(this.hitbox[t].angle - this.hitbox[t - 1].angle) > 1) {
                        continue
                    }
                    if (angle.between(this.hitbox[t].angle, this.hitbox[t - 1].angle)) {
                        if (dis < (this.hitbox[t].dis + this.hitbox[t - 1].dis) * .5) {
                            return true
                        }
                    }
                }
                return false
            }
            doesPerimeterTouch(point) {
                let link = new LineOP(point, this.metapoint)
                let angle = (link.angle() + (Math.PI * 2))
                let dis = link.hypotenuse()
                for (let t = 1; t < this.hitbox.length; t++) {
                    if (Math.abs(this.hitbox[t].angle - this.hitbox[t - 1].angle) > 1) {
                        continue
                    }
                    if (angle.between(this.hitbox[t].angle, this.hitbox[t - 1].angle)) {
                        if (dis < ((this.hitbox[t].dis + this.hitbox[t - 1].dis) * .5) + point.radius) {
                            return this.angles[t]
                        }
                    }
                }
                return false
            }
            draw() {
                this.metapoint.draw()
                let tline = new Line(this.x, this.y, this.ex, this.ey, this.color, 3)
                tline.draw()
                canvas_context.beginPath()
                this.median = new Point((this.x + this.ex) * .5, (this.y + this.ey) * .5)
                let angle = (new LineOP(this.median, this.metapoint)).angle()
                let dis = (new LineOP(this.median, this.metapoint)).hypotenuse()
                canvas_context.bezierCurveTo(this.x, this.y, this.cx - (Math.cos(angle) * dis * .38), this.cy - (Math.sin(angle) * dis * .38), this.ex, this.ey)
        
                canvas_context.fillStyle = this.color
                canvas_context.strokeStyle = this.color
                canvas_context.lineWidth = 1
                canvas_context.stroke()
            }
            getQuadraticXY(t) {
                return new Point((((1 - t) * (1 - t)) * this.x) + (2 * (1 - t) * t * this.cx) + (t * t * this.ex), (((1 - t) * (1 - t)) * this.y) + (2 * (1 - t) * t * this.cy) + (t * t * this.ey))
            }
            getQuadraticAngle(t) {
                var dx = 2 * (1 - t) * (this.cx - this.x) + 2 * t * (this.ex - this.cx);
                var dy = 2 * (1 - t) * (this.cy - this.y) + 2 * t * (this.ey - this.cy);
                return -Math.atan2(dx, dy) + 0.5 * Math.PI;
            }
        }
        
        Number.prototype.between = function(a, b, inclusive) {
            var min = Math.min(a, b),
                max = Math.max(a, b);
            return inclusive ? this >= min && this <= max : this > min && this < max;
        }
        
        // if( n < 3 && n > 1){
        
        // }
        // if((n).between(1,3)){
        
        // }
        
        
        let setup_canvas = document.getElementById('canvas') //getting canvas from document
        
        // let secretcanvas = document.getElementById('secretcanvas') //getting canvas from document
        
        // secretcanvas_context = secretcanvas.getContext('2d'); 
        setUp(setup_canvas) // setting up canvas refrences, starting timer. 
        
        // object instantiation and creation happens here 
        // class PolygonSorter {
        //     constructor(points) {
        //         this.points = points;
        //         this.hull = this.computeConcavePolygon();
        //     }
        
        //     computeConcavePolygon() {
        //         // Ensure we work on a copy of the points
        //         const points = this.points.slice();
        
        //         // Sort points by their position (you may want a specific order)
        //         points.sort((a, b) => a.x - b.x || a.y - b.y);
        
        //         // Start with the first point
        //         const polygon = [points[0]];
        
        //         // Iterate through the points to create a non-crossing concave shape
        //         for (let i = 1; i < points.length; i++) {
        //             const point = points[i];
        
        //             // Check for intersection and add the point
        //             while (polygon.length > 1 && this.doesIntersect(polygon[polygon.length - 2], polygon[polygon.length - 1], polygon[polygon.length - 1], point)) {
        //                 polygon.pop(); // Remove last point if it causes intersection
        //             }
        //             polygon.push(point);
        //         }
        
        //         // Optionally, close the polygon by connecting back to the starting point
        //         if (polygon.length > 2 && !this.doesIntersect(polygon[polygon.length - 1], polygon[0], polygon[polygon.length - 1], polygon[0])) {
        //             polygon.push(polygon[0]); // Close the polygon if it doesn't cause an intersection
        //         }
        
        //         return polygon;
        //     }
        
        //     doesIntersect(p1, q1, p2, q2) {
        //         // Helper function to check if two segments intersect
        //         return this.orientation(p1, q1, p2) !== this.orientation(p1, q1, q2) &&
        //                this.orientation(p2, q2, p1) !== this.orientation(p2, q2, q1);
        //     }
        
        //     orientation(p, q, r) {
        //         const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        //         return val === 0 ? 0 : (val > 0 ? 1 : 2); // collinear, clockwise, counterclockwise
        //     }
        
        //     minimizeArea(polygon) {
        //         // Implement a strategy to minimize the area of the polygon
        //         // This can involve a more complex triangulation method if needed
        //         return polygon; // Placeholder: Return the input polygon for now
        //     }
        
        //     getSortedPoints() {
        //         return this.minimizeArea(this.hull);
        //     }
        // }
        class PolygonSorter {
            constructor(points) {
                this.points = points;
                this.hull = this.points
            }
        
            // Function to calculate the centroid of the points
            calculateCentroid() {
                const numPoints = this.points.length;
                const sum = this.points.reduce((acc, point) => {
                    acc.x += point.x;
                    acc.y += point.y;
                    return acc;
                }, {
                    x: 0,
                    y: 0
                });
        
                return {
                    x: sum.x / numPoints,
                    y: sum.y / numPoints
                };
            }
        
            // Function to calculate the angle between the point and the centroid
            calculateAngle(point, centroid) {
                return Math.atan2(point.y - centroid.y, point.x - centroid.x);
            }
        
            // Function to sort points based on their angle relative to the centroid
            sortPointsByAngle() {
                const centroid = this.calculateCentroid();
                this.points.sort((a, b) => {
                    const angleA = this.calculateAngle(a, centroid);
                    const angleB = this.calculateAngle(b, centroid);
                    return angleA - angleB; // Sort by angle in ascending order
                });
                return this.points; // Return the sorted array
            }
        }
        
        
        
        class PolygonDrawer {
            constructor(points, color = '#000000', width = 3) {
                this.points = points; // Array of Point objects
                ////////console.l\og(points)
                this.color = color;
                this.width = width;
                this.hull = this.points
            }
        
        
            // Function to calculate the centroid of the points
            calculateCentroid() {
                const numPoints = this.points.length;
                const sum = this.points.reduce((acc, point) => {
                    acc.x += point.x;
                    acc.y += point.y;
                    return acc;
                }, {
                    x: 0,
                    y: 0
                });
        
                return {
                    x: sum.x / numPoints,
                    y: sum.y / numPoints
                };
            }
        
            // Function to calculate the angle between the point and the centroid
            calculateAngle(point, centroid) {
                return Math.atan2(point.y - centroid.y, point.x - centroid.x);
            }
        
            // Function to sort points based on their angle relative to the centroid
            sortPointsByAngle() {
                const centroid = this.calculateCentroid();
                this.points.sort((a, b) => {
                    const angleA = this.calculateAngle(a, centroid);
                    const angleB = this.calculateAngle(b, centroid);
                    return angleA - angleB; // Sort by angle in ascending order
                });
                return this.points; // Return the sorted array
            }
            drawHull() {
                if (this.liner != 1) {
        
                    this.links = []
                    for (let i = 0; i < this.hull.length; i++) {
                        const start = this.hull[i];
                        const end = this.hull[(i + 1) % this.hull.length]; // Wrap around to the first point
                        const lineOp = new LineOP(start, end, this.color, this.width);
                        lineOp.draw();
                        this.links.push(lineOp)
                    }
                }
                this.liner = 1
        
                this.sums = [0, 0, 0, 0]
                let f = 0
        
                for (let t = 0; t < people.length; t++) {
                    if (isPointInPolygon(this.hull, people[t].body)) {
                        this.sums[people[t].type]++
                        f++
                    }
                }
        
                // Determine the color based on which sum is maximum
                let calccolor;
                ////////console.l\og(this.sums)
                const maxSum = Math.max(...this.sums);
                const maxIndex = this.sums.indexOf(maxSum);
        
                if (f != groups[groupi]) {
                    calccolor = '#88888888'
                    this.t = -1
                } else {
        
                    if (maxIndex === 0) {
                        calccolor = '#ff000040';
                        this.t = 0
                    } else if (maxIndex === 1) {
                        this.t = 1
                        calccolor = '#00ff0040';
                    } else if (maxIndex === 2) {
                        this.t = 2
                        calccolor = '#0000ff40';
                    } else if (maxIndex === 3) {
                        this.t = 3
                        calccolor = '#ffff0040';
                    } else {
                        this.t = -1
                        calccolor = 'white'; // Replace with a color for index 2 and 3 if needed
                    }
        
                }
        
                const maxCount = this.sums.filter(sum => sum === maxSum).length;
        
                if (maxCount > 1) {
                    calccolor = '#88888888'; // Set to gray if there are ties
                }
        
        
                fillPolygon(canvas_context, this.hull, calccolor)
            }
        }
        
        function fillPolygon(ctx, points, color) {
            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
        
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
        
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        }
        
        class People {
            constructor(x, y, colorValue) {
                this.type = colorValue
                this.body = new Circle(x, y, 50, "white");
                this.colors = ['red', '#00ff00', 'blue', 'yellow'];
        
                this.body.color = this.colors[colorValue % 4];
            }
        
            // Check if the circle is on the line
            isCircleOnLine(link) {
                this.body.radius = 50
                const x = this.body.x;
                const y = this.body.y;
                const radius = this.body.radius;
        
                // Line is defined by two points (x1, y1) and (x2, y2)
                // const [x1, y1, x2, y2] = link;
                const x1 = link.object.x
                const x2 = link.target.x
                const y1 = link.object.y
                const y2 = link.target.y
        
                // Line equation: Ax + By + C = 0
                const A = y2 - y1;
                const B = x1 - x2;
                const C = x2 * y1 - x1 * y2;
        
                // Distance from circle center to the line
                const distance = Math.abs(A * x + B * y + C) / Math.sqrt(A * A + B * B);
        
                // Check if the distance is less than or equal to the radius
                return distance <= radius;
            }
            draw() {
                this.body.radius = 10
                this.body.draw()
            }
        }
        let hulls = []
        let hull = []
        let people = []
        let peo = []
        
        let groups = [3, 4, 5, 6, 10, 12]
        
        let diff = 2
        let groupi = 3
        for (let t = 0; t < 60; t++) {
            peo.push(t % diff)
        }
        
        for (let t = 0; t < 60; t++) {
            let per = new People(100 + (100 * (t % 10)), 100 + (100 * Math.floor(t / 10)), peo[t])
        
            people.push(per)
        }
        
        
        function isPointInPolygon(point, polygon) {
            const {
                x,
                y
            } = point;
            let isInside = false;
        
            // Loop through each edge of the polygon
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const {
                    x: xi,
                    y: yi
                } = polygon[i];
                const {
                    x: xj,
                    y: yj
                } = polygon[j];
        
                // Check if the point is inside the polygon
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        
                if (intersect) {
                    isInside = !isInside;
                }
            }
        
            return isInside;
        }
        
        let h1 = {}
        let sure = {}
        
        function isPointInPolygon(points, testPoint) {
            const x = testPoint.x;
            const y = testPoint.y;
            let inside = false;
        
            for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
                const xi = points[i].x;
                const yi = points[i].y;
                const xj = points[j].x;
                const yj = points[j].y;
        
                const intersect = ((yi > y) !== (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        
                if (intersect) {
                    inside = !inside;
                }
            }
        
            return inside;
        }
        
        function arePointsOverlapping(a, b, c, d, e, f, g, h) {
            // Create an array of points from the provided coordinates
            const points = [{
                    x: a,
                    y: b
                }, // First point
                {
                    x: c,
                    y: d
                }, // Second point
                {
                    x: e,
                    y: f
                }, // Third point
                {
                    x: g,
                    y: h
                } // Fourth point
            ];
        
            ////////////////////////console.log(points)
            // Use a Set to track unique positions
            const uniquePositions = new Set();
        
            for (const point of points) {
                // Create a unique key for each point based on its x and y values
                const key = `${point.x},${point.y}`;
        
                // If the key is already in the Set, return true (overlapping point found)
                if (uniquePositions.has(key)) {
                    return true;
                }
        
                // Add the key to the Set
                uniquePositions.add(key);
            }
        
            // No overlapping points found
            return false;
        }
        // returns true if the line from (a,b)->(c,d) intersects with (p,q)->(r,s)
        function intersects(a, b, c, d, p, q, r, s) {
            var det, gamma, lambda;
            a = Math.round(a)
            b = Math.round(b)
            c = Math.round(c)
            d = Math.round(d)
            p = Math.round(p)
            q = Math.round(q)
            r = Math.round(r)
            s = Math.round(s)
            ////////////////////////console.log(arePointsOverlapping(a, b, c, d, p, q, r, s))
            if (arePointsOverlapping(a, b, c, d, p, q, r, s)) {
                return false
            }
        
        
            det = (c - a) * (s - q) - (r - p) * (d - b);
            if (det === 0) {
                return false;
            } else {
                lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;
                gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;
                return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
            }
        };
        
        
        
        
        // Example usage
        // const polygon1 = [{x: 1, y: 1}, {x: 3, y: 3}, {x: 1, y: 3}, {x: 3, y: 1}]; // Self-intersecting
        // const polygon2 = [{x: 1, y: 1}, {x: 1, y: 5}, {x: 5, y: 5}, {x: 5, y: 1}]; // Not self-intersecting
        
        // ////////console.l\og(isPolygonSelfIntersecting(polygon1)); // true
        // ////////console.l\og(isPolygonSelfIntersecting(polygon2)); // false
        
        
        
        
        class Puppeteer {
            constructor(points, personSpawnID, targetRoom, footing, targetID) {
                this.points = points //points is a list of x,y objects like {"x":10,"y":12}, they will be in an array like [point1, point2, point3] etc.
                this.targetRoom = targetRoom //Target room is where the new character will spawn
                this.personSpawnID = personSpawnID //this is the ID of who will spawn in the room (at the footing)
                this.footing = footing //this is an  x,y object, just one, not a list, like point =  {"x":10,"y":12}, and it's where the npc will spawn
                this.targetID = targetID //this is the ID of who will be moved in the room to a new position, and will tag their people object to animate a walk animation(which exist)
        
        
                //animation variables, these control the puppeting 
                this.count = 0 //what "frame" of the interpolation between the points selected
                this.pointer1 = 0; //this is the starting point in the array for where to interopolate from
                this.ponter2 = 1 // this is the number that is the index of the point to interpolate to 
                this.distances = [] //arraay this holds the distances in pixels from A to B as they traverse
                this.lengths = [] //the lengths in frames of how long they will be walking from a to b
                this.link = new LineOP(this.points[0].this.points[1]) //dummy line object for geometry
                for (let t = 1; t < this.points.length; t++) { //loop for calculating the distances and lengths
                    this.link.target = this.points[t] //this sets the line geometry to measure from the point at index t
                    this.link.object = this.points[t - 1] //this sets the line geometry to measure to the point at index t-1,,this with the array starting loop at 1 means it won't overflow, regardless of the points, as long as there are two or more
                    let h = this.link.hypotenuse() //h is the hypotenuse of the line that connects the points in question, and makes for a measure of their euclidian distance
                    this.distances.push(h) //then we store that distance
                    this.lengths.push(Math.ceil(h / 6)) //and also store the length in frames they will be animated for
                }
        
        
        
                this.active = 1 // sets up to run automatically on formation of trigger
        
            }
            interpolate(point1, point2, time, length) {
                let x = point1.x + ((point2.x - point1.x) * (time / length)) //averaging from x to x on a time slider
                let y = point1.y + ((point2.y - point1.y) * (time / length)) //averaging from y to y on a time slider
                return {
                    "x": x,
                    "y": y
                }
            }
            play() { //this will be on all triggerd puppet objects, in a loop of their array, in main probably at the top, and there will need to be a cleanup function
                if (this.active == 1) {
        
                    //lookup people data and convert them to a class variable called target person
                    this.targetPerson = {} //lookup
        
                    let interpoint = this.interpolate(this.points[this.pointer1], this.points[this.ponter2], this.count, this.lengths[this.ponter2]) //call for the creation of a point that is where the npc should be drawn
                    this.targetPerson.x = interpoint.x
                    this.targetPerson.y = interpoint.y
        
        
                    this.count++
                    if (this.count > this.lengths[this.ponter2]) {
                        this.count = 0
                        this.pointer1++ //increment to the next point
                        this.pointer2++ //increment to the next point
                        if (this.pointer2 > this.lengths.length) { //if it's the ned, tun the swap
        
                            this.targetPerson.kill = 1 //code to remove target person from the array of people
        
                            let newDude = new Person(this.personSpawnID, this.footing.x, this.footing.y) //code to add people to other room 
                            people[this.targetRoom].push(newDude)
                            this.cleanup()
                        }
                    }
                }
        
            }
            cleanup() {
                this.active = 0
            }
        
        }
        
        
        class GeneTable {
            constructor() {
                this.pairs = []
                this.alphabet = ("PO").split('')
                for (let t = 0; t < this.alphabet.length; t++) {
                    for (let k = 0; k < this.alphabet.length; k++) {
                        let p = ''
                        p += this.alphabet[t]
                        p += this.alphabet[k]
                        this.pairs.push(p)
                    }
                }
                this.hash = {}
        
        
                // 3
                // +
                // -
                // 0
        
                this.lester = []
                for (let t = 0; t < this.pairs.length; t++) {
                    this.lester.push(t % 9)
                }
        
                for (let t = 0; t < this.pairs.length; t++) {
                    this.hash[this.pairs[t]] = this.lester[t]
                }
                ////////////////////////console.log(this)
            }
        }
        
        
        let colors = ["REd", "orange", "yellow", "#00ff00", 'cyan', "blue", "indigo", "violet", "magenta"]
        class Amine {
            constructor(i, t) {
                this.body = new Circle(180 + (i * 10), 360 + (Math.random() * 10), 5, colors[t])
                this.link = new LineOP(this.body, this.body)
                this.type = t
                this.friction = 1 - (this.type * .001)
            }
            draw() {
                this.body.draw()
            }
            move() {
                this.body.frictiveMove()
            }
        }
        
        
        //all my worst injuries are self inflicted
        //asked how I feel about failing I say I'm addicted 
        
        class Organism {
            constructor() {
                this.genes = []
                this.alphabet = ("PO").split('')
                this.geneslist = []
                for (let t = 0; t < 40; t++) {
                    this.geneslist.push(this.alphabet[Math.floor(Math.random() * this.alphabet.length)] + this.alphabet[Math.floor(Math.random() * this.alphabet.length)])
                }
        
                this.spr = []
                for (let t = 0; t < 40; t++) {
                    let ami = new Amine(t, genetable.hash[this.geneslist[t]])
        
                    this.genes.push(ami)
        
                    if (t > 0) {
                        let spring = new SpringOP(this.genes[t - 1].body, ami.body, 11, 1, 'transparent')
                        this.spr.push(spring)
                    }
        
                }
            }
            draw() {
                for (let t = 0; t < this.genes.length; t++) {
                    this.genes[t].draw()
                    this.genes[t].move()
        
                    for (let k = 0; k < this.genes.length; k++) {
                        if (k != t) {
        
        
                            this.genes[t].link.target = this.genes[k].body
                            if (this.genes[t].link.hypotenuse() < 10) {
        
                                this.genes[t].body.x += Math.cos(this.genes[t].link.angle()) / 3
                                this.genes[t].body.y += Math.sin(this.genes[t].link.angle()) / 3
                            }
                            if (this.genes[t].link.hypotenuse() < 20) {
                                this.genes[t].body.x += Math.cos(this.genes[t].link.angle()) / 40
                                this.genes[t].body.y += Math.sin(this.genes[t].link.angle()) / 40
                            }
                        }
                    }
        
                    for (let k = 0; k < this.genes.length; k++) {
                        if (this.genes[t].type == this.genes[k].type) {
                            if (k != t) {
                                this.genes[t].link.target = this.genes[k].body
                                if (this.genes[t].link.hypotenuse() < 20) {
                                    this.genes[t].body.x -= Math.cos(this.genes[t].link.angle()) / 40
                                    this.genes[t].body.y -= Math.sin(this.genes[t].link.angle()) / 40
                                }
                            }
                        }
                    }
        
        
                }
                for (let t = 0; t < this.spr.length; t++) {
                    this.spr[t].balance()
                }
            }
        }
        
        let genetable = new GeneTable()
        
        
        
        let organeo = new Organism()
        
        
        ////////////////////////console.log(organeo)
        
        let rmod = Math.floor(Math.random() * 25) + 5
        let gmod = Math.floor(Math.random() * 25) + 5
        let bmod = Math.floor(Math.random() * 25) + 5
        
        rmod = 1
        bmod = 1
        gmod = 1
        
        
        function getIndex(x, y, width) {
            return (y * width + x) * 4;
        }
        
        
        class Counter {
            constructor() {
        
            }
        }
        
        let seenToday = {}
        let superclick = 0
        let startedinit = 0
        class Node {
            constructor(x, y, t, genes, nope = 0) {
                this.energyOrgCost = 0
                this.nodeEnergyCost = 0
                
                this.xavg = 0
                this.yavg = 0
                this.charge = 0
                this.magratio = 1
                // if(Math.random() < .66){
                //     this.charge = Math.sign(Math.random()-.5)
                // }
                this.genestring = genes
                this.genebucket = ['P']
                this.magbucket = [1]
                this.chargebucket = [0]
                this.trueage = 0
                this.pistonpush = 0
                this.pistonpushes = []
                this.pistontime = 0
                this.pistonstep = (Math.random()+.5)/10
                this.shead =0
                this.birthx = Math.random()-.5
                this.birthy = Math.random()-.5
                this.r = Math.random()*255
                this.g = Math.random()*255
                this.b = Math.random()*255
                this.p = Math.random()*255
                this.m = Math.random()*255
                this.z = Math.random()*255
                this.q = Math.random()*255
                this.linkup = []
                this.prime = 0
                this.connected = 0
                this.head = 0
                this.ll = 0
                this.dcon = []
                if(t == 5){
                    this.mouth = 1
                }
                this.caught = 0
                this.age = 0
                this.xleap = 0
                this.yleap = 0
                this.immune = []
                this.stupidimmune = []
                this.neighbors = []
                this.stupidneighbors = []
                this.type = t
                this.id = superclick
                superclick++
                this.x = x
                this.y = y
                if(nope == 0){
                    this.link = new LineOP(this, this, "#808080")
                    this.link.list  =[]
                }
                this.lout = ((loutmin*worldscaler) + 2) - ((Math.random()-.5)*4)
                this.loutin = this.lout
                this.las = []
                this.happy = true
                for (let t = 0; t < timesLength; t++) {
                    this.las.push(Math.random() * 6.283)
                }
                this.rigs = []
                this.
                times = []
                this.subticks = []
                for (let t = 0; t < timesLength; t++) {
                    this.subticks.push(((Math.random() - .5) / 16))
                }
                this.ticks = []
            
                this.pistonstarts = []
                this.pistontimes = []
                this.pistonticks = []
                for (let t = 0; t < timesLength; t++) {
                    this.times.push(0)
                    this.pistontimes.push(0)
                    this.pistonstarts.push(Math.random()*10000)
                    this.pistonpushes.push((Math.random()*(loutmin*worldscaler)*3.5) - ((loutmin*worldscaler)*.5))
                    this.ticks.push(((Math.random() - .5) / 16))
                    this.pistonticks.push(((((Math.random() - .5)))*2)/10) 
                }
                this.subrots = []
                for (let t = 0; t < timesLength; t++) {
                    this.subrots.push(((Math.random() - .5) / 6))
                }
                for (let t = 0; t < timesLength; t++) {
                    this.rigs.push(1-((Math.random() / 4) +.75))
                }
                this.pushout =  Math.random() * 6.283
                this.pushoutsto = this.pushout
                // ////////////////////////console.log(this.id)
                if(nope == 0){
                    globalnodes.push(this)
                }
                this.energy = 0
                this.generate = 0
                if (this.type == 4 || this.type == 7 || this.type == 8 || this.type ==14 || this.type == 11|| this.type == 9) {
                    this.generate = generationConstant
                }
                this.gencap = 100000000 //holycrap this kills complexity sub 1000
                this.energy = 0
        
                this.hit = 0
                this.lt = new Point(this.x, this.y)
    
            }
            freeenergy(){
                this.link.object = this
                this.nodeEnergyCost = 0
            }
            map(k,f){
                if(this.dead == 1){
                    return
                }
    
                let scare = {}
    
                for(let d = 0;d<f.length;d++){
                    scare[k[d]] = d
                }
                return scare
            }
            dupe(num){
                // //////////////////console.log(num)
                if(this.dead == 1){
                    //console.log("s")
                    if(this.mouth == 1){
                        //////console.log("T")
                    }
                    return false
                }
    
                let alldead = 0
                for(let t = 0;t<globalnodes.length;t++){
                    if(globalnodes[t].dead ==1){
                        alldead++
                    }
                }
    
                if((globalnodes.length-alldead) >= nodecap-(this.immune.length*2) || num == 0){
    
                    //console.log("s")
                    if(this.mouth == 1){
                        //////console.log("T")
                    } 
                    return false
                }
                // let node = new Node(Math.random()*360 ,Math.random()*360, this.type)
                // if(this.age > minage){
                    // this.age = minage
                    let node 
    
                    if((Math.random() < mutationrate*1) && this.head != 1){
    
                    if(this.mouth == 1){
                        //////console.log("T")
                    } 
    
                    //console.log("s")
                        return false
                    }else{
                        if((Math.random() < mutationrate)){
                            // node = new Node(this.x+((Math.random()-.5)*20), this.y+((Math.random()-.5)*20) , Math.floor(Math.random()*nodetypes))
    
                            if(codonusage == 1){
                            let g = mutateGenes(this.genestring)
                            node = new Node(this.x+((this.birthx*Math.cos(this.pushout))*((loutmin*worldscaler)*1.5)), this.y+((this.birthy+Math.sin(this.pushout))*((loutmin*worldscaler)*1.5)) , geneToType(g), g)
                            node.head = this.head
                            headout = 1
                            }else{
                            let g = mutateGenes(this.genestring)
                            node = new Node(this.x+((this.birthx*Math.cos(this.pushout))*((loutmin*worldscaler)*1.5)), this.y+((this.birthy+Math.sin(this.pushout))*((loutmin*worldscaler)*1.5)) , Math.floor(Math.random()*(nodetypes-1)), g)  //-1 because disease
                            node.head = this.head
                            headout = 1
                            }
                        }else{ 
                            if(codonusage == 1){
                                let g = mutateGenes(this.genestring)
                                node = new Node(this.x+((this.birthx*Math.cos(this.pushout))*((loutmin*worldscaler)*1.5)), this.y+((this.birthy+Math.sin(this.pushout))*((loutmin*worldscaler)*1.5)) , geneToType(g), g)
                                node.head = this.head
                                headout = 1
                            }else{
                                let g = this.genestring
                                node = new Node(this.x+((this.birthx*Math.cos(this.pushout))*((loutmin*worldscaler)*1.5)), this.y+((this.birthy+Math.sin(this.pushout))*((loutmin*worldscaler)*1.5)) , this.type, g)
                                node.head = this.head
                                headout = 1
                            }
    
                        }
        
                    }
    
                    //ticks rigs pushout sto time
    
                    if(Math.random() < mutationrate){
                        node.charge = 0
                        if(Math.random() < .66){
                            node.charge = Math.sign(Math.random()-.5)
                        }
                    }else{
                        node.charge = this.charge
                    }
    
                    node.magratio = this.magratio
    
                    if(Math.random() < mutationrate){
    
                        node.magratio = this.magratio+((Math.random()-.5)/4)
    
                    }
    
                    node.magratio = Math.min(Math.max(node.magratio,0),magratmax)
    
                    
                    if(Math.random() < mutationrate){
                        node.birthx = this.birthx + ((Math.random()-.5))
                        node.birthx = Math.max(Math.min(node.birthx, .5),-.5)
                    }else{
                        node.birthx = this.birthx 
                    }
    
                    if(Math.random() < mutationrate){
                        node.birthy = this.birthy + ((Math.random()-.5))
                        node.birthy = Math.max(Math.min(node.birthy, .5),-.5)
                    }else{
                        node.birthy = this.birthy 
                    }
    
    
                    node.ticks = [...this.ticks]
                    node.pistonticks = [...this.pistonticks]
                    node.subticks = [...this.subticks]
                    node.subrots = [...this.subrots]
    
                    for(let t = 0;t<node.ticks.length;t++){
                        if((Math.random() < mutationrate)){
                            node.ticks[t] += ((Math.random()-.5)/32)
                        }
                        if((Math.random() < mutationrate)){
                            node.ticks[t] = ((Math.random() - .5) / 16)
                        }
                    }
    
                    for(let t = 0;t<node.pistonticks.length;t++){
                        if((Math.random() < mutationrate)){
                            node.pistonticks[t] += ((Math.random()-.5)/10)
                        }
                        if((Math.random() < mutationrate)){
                            node.pistonticks[t] = ((((Math.random() - .5)))*2)/10
                        }
                    }
    
                    for(let t = 0;t<node.subticks.length;t++){
                        if((Math.random() < mutationrate)){
                            node.subticks[t] += ((Math.random()-.5)/32)
                        }
                        if((Math.random() < mutationrate)){
                            node.subticks[t] = ((Math.random() - .5) / 16)
                        }
                    }
                    for(let t = 0;t<node.subrots.length;t++){
                        if((Math.random() < mutationrate)){
                            node.subrots[t] += ((Math.random()-.5)/32)
                        }
                        if((Math.random() < mutationrate)){
                            node.subrots[t] = ((Math.random() - .5) / 16)
                        }
                    }
    
                    node.rigs = [...this.rigs]
                    node.pistonstarts = [...this.pistonstarts]
    
                    node.r = Math.max(Math.min(255, this.r+((Math.random()-.5)*32)),0)
                    node.g = Math.max(Math.min(255, this.g+((Math.random()-.5)*32)),0)
                    node.b = Math.max(Math.min(255, this.b+((Math.random()-.5)*32)),0)
                    node.p = Math.max(Math.min(255, this.p+((Math.random()-.5)*32)),0)
                    node.m = Math.max(Math.min(255, this.m+((Math.random()-.5)*32)),0)
                    node.z = Math.max(Math.min(255, this.z+((Math.random()-.5)*32)),0)
                    node.q = Math.max(Math.min(255, this.q+((Math.random()-.5)*32)),0)
    
                    for(let t = 0;t<node.rigs.length;t++){
                        if((Math.random() < mutationrate)){
                            node.rigs[t] = (1-((Math.random() / 4) +.75))
                        }
                    }
                    for(let t = 0;t<node.pistonstarts.length;t++){
                        if((Math.random() < mutationrate)){
                            node.pistonstarts[t] =(Math.random()*100000)
                        }
                        if((Math.random() < mutationrate)){
                            node.pistonstarts[t] +=((Math.random()-.5)*(Math.PI*2))
                        }
                    }
    
                    node.pushoutsto = this.pushoutsto
                    node.pushout = this.pushout
    
                    if((Math.random() < mutationrate*1)){
                        node.pushout = Math.random()*Math.PI*2
                    }
    
    
    
                    node.lout = Math.max(this.lout + ((Math.random()-.5)*2),(loutmin*worldscaler))
                    node.loutin = node.lout
                    if((Math.random() < mutationrate*1)){
                    node.pistonstep = this.pistonstep+ ((((Math.random()-.5)*1))/10)
                    }else{
                        node.pistonstep = this.pistonstep
                    }
                    if((Math.random() < mutationrate*1)){
                        // node.cut = 1
                    }else{
    
                        if(Math.random() < mutationrate){
    
                            let superduper = {}
                            if(deadwash == deadmax-1){
    
                                //////console.log("W")
                                superduper.linkto = globalnodes.indexOf(node)
                            }else{
    
                                //////console.log("M")
                            superduper.linkto = globalnodes.indexOf(node)
                            }
                            superduper.x = node.x
                            superduper.y = node.y
                            superduper.type = Math.floor(Math.random()*(nodetypes-1)) //-1 because disease
                            let gr = this.genestring
                            let ch = this.charge
                            let mh = this.magratio
                            if(Math.random() < .33){
                                gr = ''
                                ch = 0
                                mh = 1
             
                                if(Math.random() < mutationrate){
                                    mh = mh+((Math.random()-.5))
                                }
                                mh = Math.min(Math.max(mh,0),magratmax)
    
    
                                if(Math.random() < .66){
                                    if(Math.random() <.5){
                                        ch = 1
                                    }else{
                                        ch = -1
                                    }
                                }
                            for(let r = 0;r<genelength;r++){
                                gr+=geneChars[Math.floor(Math.random()*geneChars.length)]
                            }
                            ch = this.charge
                            mh = this.magratio
                            }else   if(Math.random() < .33){
                                gr = this.genebucket[Math.floor(Math.random()*this.genebucket.length)]
                                ch = this.chargebucket[Math.floor(Math.random()*this.chargebucket.length)]
                                mh = this.magbucket[Math.floor(Math.random()*this.magbucket.length)]
                            }
                            superduper.genestring = gr
                            if(Math.random() < mutationrate*3){ //2
                            superduper.radio = 1
                            }else{
                                superduper.radio = 0
                            }
                            if(Math.random() < mutationrate*3){ //2
                                superduper.extra = 1
                            }else{
                                superduper.extra = 0 
                            }
    
                            superduper.charge = ch
                            globduper.push(superduper)
                            
            
                            }
            
    
                    }
    
                    return node
                // }
    
    
                if(this.mouth == 1){
                    //////console.log(this)
                } 
                return false
            } 
    
    
            //a teleporting magnolia tree that goes on adventures but lives on one place
            tupe(macro, node){
                let alldead = 0
                for(let t = 0;t<globalnodes.length;t++){
                    if(globalnodes[t].dead ==1){
                        alldead++
                    }
                }
    
                if((globalnodes.length-alldead) >= nodecap-(this.immune.length*2)){
                    return false
                }
                if(this.dead == 1){
                    return
                }
                let table = []
                // for(let t= 0 ;t<macro.f.length;t++){
                //     table[macro.f[t]] = t
                // }
                //  let  babble  = macro.match[me]
                //  ////////////////////console.log(macro.f, node.linkup)
                //  ////////////////////console.log(table)
                if(node.linkup.length > 1){
                    //console.log(node)
                }
                for(let t= 0 ;t<node.linkup.length;t++){
                let offset = macro.f.indexOf(node.linkup[t])
                // //////////////////console.log(offset, macro.f, node.linkup) 
                    if(offset+macro.start <= globalnodes.length){
                if(globalnodes[offset+macro.start].hitcon != 1){
                if(offset != -1){
      
                    node.connected++
                    globalnodes[(offset+macro.start)].connected++
                        node.connect(globalnodes[(offset+macro.start)])
                        if(node.connected > 2){
                            
                            //console.log(node, globalnodes[(offset+macro.start)], macro)
                        }    
                         if(globalnodes[(offset+macro.start)].connected >2){
                            //console.log(node, globalnodes[(offset+macro.start)], macro)
                        }
                    }
                    // ////////////////////console.log(globalnodes[(offset+macro.start)].type, globalnodes[node.linkup[t]].type)
                    // globalnodes[offset+macro.start].hitcon = 1
                    // node.hitcon = 1
                }
                }
                }
            }
    
    
    
    
    
    
            // tupe(num, macro, me,node){
            //     if(globalnodes.length > nodecap || num == 0){
            //         return
            //     }
            //     let keys = Object.keys(macro.match)
            //     let arts = this.map(keys, macro.f)
    
            //     //////////////////////console.log( arts, me)
            //     let letters = macro.match[arts[me]] 
            //     for(let t = 0;t<letters.length;t++){
            //         if(globalnodes[letters[t]+macro.start]){
    
            //         node.connect(globalnodes[letters[t]+macro.start])
            //         }
            //     }
            // }
            energyBalance(){
                this.m = -1
                this.balanced = 1
                if(this.head != 1){
                    return
                }
                if(this.hit == 1){
                    return
                }
                if(this.dead == 1){
    
                    if(this.firsty != 1){
                        for(let t = 0;t<this.neighbors.length;t++){
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    return
                }
    
                if(this.caught == 1){
                    return
                }
    
    
    
                let glist = [this]
    
                let flist = [this]
            
                let runsum = this.prime
                let runprod = this.prime
                let f = [globalnodes.indexOf(this)]
                for(let t =0 ;t<flist.length;t++){
                    if(flist[t]){ 
                        for(let k = 0;k<flist[t].neighbors.length;k++){
                              if(f.includes((flist[t].neighbors[k])) ){ //|| globalnodes[flist[t].neighbors[k]].dead == 1
                              }else{
                                if(globalnodes[flist[t].neighbors[k]]){
                                    runprod*=globalnodes[flist[t].neighbors[k]].prime
                                    runsum+=globalnodes[flist[t].neighbors[k]].prime
                                    f.push((flist[t].neighbors[k]))
                                    // if(flist[t]){ 
                                    flist.push(globalnodes[flist[t].neighbors[k]])
    
                                }
                                // }
                              }
                        }
    
                    }
                }
    
    
    
    
                // ////////////////////console.log(flist)
                for(let t =0 ;t<flist.length;t++){
                    for(let k = 0;k<flist[t].neighbors.length;k++){
                        if(f.includes((flist[t].neighbors[k]))){
    
    
                            // ////////////////////console.log(flist)
                            let screw = 0
                            let snapout =0
                            for(let w = 0;w<glist.length;w++){
                                if(snapout == 1){
                                    continue
                                }
                                if(glist[w].x > -10000){ 
                                    screw = -1
                                }
                                if(keysPressed['g']){
                                ////////////////////console.log(globalnodes[flist[t].neighbors[k]].id)
                                }
                                if(glist[w].id == globalnodes[flist[t].neighbors[k]].id){ 
                                 screw = 1
                                 snapout =1
                                //  ////////////////////console.log('s')
                                }
                            }
    
    
                            if(screw == -1){
                                glist.push(globalnodes[flist[t].neighbors[k]])
    
                            }
                        }
                    }
                }
    
    
    
                for(let t = 0;t<glist.length;t++){
                    if(glist[t].radio == 1){
                        let met = Math.floor(Math.random()*glist.length)
                        if(met != t){
                            glist[t].radio = 0
                            glist[t].connect(glist[met])
                        }
                    }
    
                }
    
                for(let t = 0;t<glist.length;t++){
                    if(glist[t].extra == 1){
                        let met = Math.floor(Math.random()*glist.length)
                        let mek = Math.floor(Math.random()*glist.length)
                        ////////////////console.log(met, mek) 
                        if(met != mek){
                            glist[t].extra = 0
                            glist[mek].connect(glist[met])
                        }
                    }
    
                }
    
                
                if(keysPressed['g']){
                    ////////////////////console.log(f,glist)
                }
                let g = 0 
                let m = 0
                let ag = 0
                let ll = 0
                let p = 0
                let eoc = 0
    
                for(let t =0 ;t<glist.length;t++){
                    glist[t].immune = []
                    glist[t].stupidimmune = []
                    glist[t].caught  = 1
                }
    
                for(let t =0 ;t<glist.length;t++){
                    for(let k =0 ;k<glist.length;k++){
                    glist[t].immune.push(globalnodes.indexOf(glist[k]))
                    glist[k].immune.push(globalnodes.indexOf(glist[t]))
                    glist[k].stupidimmune[glist[t].id ]= 1
                    glist[t].stupidimmune[glist[k].id ] = 1
    
    
                    }
                }
    
    
    
                for(let t =0 ;t<glist.length;t++){
                    // for(let k = 0;k<glist[t].link.list.length;k++){
                        g += glist[t].energy
                        p += glist[t].pushoutsto
                        ag += glist[t].age
                        ll += (glist[t].immune.length+1)
                        eoc += glist[t].nodeEnergyCost
                        m++
                    // }
                }
    
                if(keysPressed[' ']){
                    ////////////////////////console.log(glist)
                }
                g/=m
                p/=m
                ag/=m
                ll/=m
    
    
                // ////////////////////////console.log(g,m)
    
                let matmatch = {}
                let startin = globalnodes.length
                let macro = {}
                macro.match = matmatch
                macro.start = startin
                macro.f = f.sort((a,b)=>a>b?1:-1)
    
                this.m = m
                g = Math.min((repconstant*((((m))))),g)
                if(g >= (repconstant*((((m))))) && glist.length>1 && macrodupe == 0 && deadwash < deadmax-3 && deadwash > 3){
                  
                    //////////////////console.log((100*(Math.sqrt(Math.sqrt((m*30)-25)))) ,g)
                    glist.sort((a,b)=>globalnodes.indexOf(a)>globalnodes.indexOf(b)?1:-1)
                    // macrodupe = 1
    
                    ////////////////////console.log(glist)
                    for(let t =0 ;t<glist.length;t++){
                            matmatch[globalnodes.indexOf(glist[t])] = []
                            // let mv  = []
                        for(let k = 0;k<glist[t].link.list.length;k++){
                            if(!matmatch[globalnodes.indexOf(glist[t])].includes(glist[t].link.list[k])){
                                // mv.push(glist[t].link.list[k])
                                matmatch[globalnodes.indexOf(glist[t])].push(glist[t].link.list[k]) 
                            } 
                        }
    
                    }
    
    
    
                    let nodds = []
                    headout = 0
                        let kills = []
                    for(let t =0 ;t<glist.length;t++){
    
                        // //////////////////console.log(glist[t].neighbors.length)
                        let nodd = glist[t].dupe(glist[t].neighbors.length)
    
                        if(nodd != false){
    
                            if(glist[t].neighbors.length > 1){
                                ////console.log("W")
                            }
                            nodd.linkup = [...glist[t].neighbors] 
                            if(Math.random() < mutationrate){
                                let pos = macro.f[Math.floor(Math.random()*macro.f.length)]
                                if(nodd.linkup.includes(pos)){
                                }else{
                                    nodd.linkup.push(pos)
                                }
                            }
                            nodd.t = globalnodes.indexOf(glist[t])
                            nodds.push(nodd)
                        }else{
                            kills.push(globalnodes.indexOf(glist[t]))
                            ////////////console.log(matmatch)
    
                            // glist[t].neighbors.splice(glist[t].neighbors.indexOf(globalnodes.indexOf(glist[t])),1)
                            ////console.log(macro.f)
    
                            macro.f.splice(macro.f.indexOf(globalnodes.indexOf(glist[t])),1)
                            ////console.log(macro.f)
    
    
    
    
                            // let key = Object.keys(matmatch)
                            // for(let z = 0;z<key.length;z++){
                            //     if(key[z] == glist[t].id){
                            //         delete matmatch[key[z]]
                            //     }else{
                            //         for(let q = 0;q<matmatch[key[z]].length;q++){
                            //             ////////////console.log(matmatch[key[z]].indexOf(glist[t].id))
                            //             matmatch[key[z]].splice(matmatch[key[z]].indexOf(glist[t].id),1)
                            //         }
                            //     }
                            // }
                            
    
    
    
                            // return
                        }
                    }
    
    
    
    
                    for(let t =0 ;t<kills.length;t++){
                    for(let ww = 0;ww<nodds.length;ww++){
                        ////////////console.log(nodds[ww].linkup.indexOf(glist[t].id))
                        ////console.log(nodds[ww].linkup)
                        nodds[ww].linkup.splice(nodds[ww].linkup.indexOf(kills[t]),1)
                        ////console.log(nodds[ww].linkup)
    
                    }
                }
                    if(nodds.length > 0){
    
                        g -= (repconstant*((((m))))) 
                    }
                    for(let t =0 ;t<nodds.length;t++){
                        nodds[t].tupe(macro, nodds[t])
                        for(let k =0 ;k<nodds.length;k++){
                            // nodds[k].hitcon = 0
                        }
                    }
    
    
                    for(let t =0 ;t<nodds.length;t++){
                        if(nodds[t].cut == 1){ //no
     
                            
                            for(let w = 0;w<globalnodes.length;w++){
    
                            }
                        for(let k = 0;k<nodds[t].neighbors.length;k++){
                            globalnodes[nodds[t].neighbors[k]].disconnect(nodds[t])
                            // .disconnect() //
                        }
    
                        // nodds[t].dead = 1
                            // for(let k = 0;k<nodds.length;k++){
                            //     nodds[k].disconnect(nodds[t])
                            // }
                        }
                    }
                    for(let t =0 ;t<nodds.length;t++){
                        nodds[t].hitcon = 0
                    }
    
    
                    // ////////////////////////console.log(macro)
                } 
    
                let x = 0
                let y = 0
                for(let t =0 ;t<glist.length;t++){
                    glist[t].genebucket = []
                    glist[t].chargebucket = []
                    glist[t].magbucket = []
    
                }
                for(let t =0 ;t<glist.length;t++){
                    // for(let k = 0;k<glist[t].link.list.length;k++){
                        glist[t].energy = g
                        glist[t].pushoutsto = p
                        glist[t].age = ag
                        glist[t].ll = ll
                        glist[t].hit = 1
                        glist[t].head = 0
                        glist[t].runsum = runsum
                        glist[t].runprod = runprod
                        glist[t].energyOrgCost = eoc
                        
    
    
                        glist[t].r = this.r
                        glist[t].g = this.g
                        glist[t].b = this.b
                        glist[t].z = this.z
                        glist[t].m = this.m
                        glist[t].p = this.p
                        glist[t].q = this.q
    
    
                        x+=glist[t].x
                        y+=glist[t].y
                        for(let k =0 ;k<glist.length;k++){
                            glist[t].genebucket.push(glist[k].genestring)
                            glist[t].chargebucket.push(glist[k].charge)
                            glist[t].magbucket.push(glist[k].magratio)
    
                        }
                    // }
                }
                
                y/=m
                x/=m
    
                for(let t =0 ;t<glist.length;t++){
                    glist[t].xavg = x
                    glist[t].yavg = y
                    glist[t].shead = globalnodes.indexOf(this)
                }
                if(edgeLoop ==1){
    
                    if(x <-3){
    
                        ////////console.log(this.immune.length, glist.length)
                        for(let t =0 ;t<glist.length;t++){
                            glist[t].xleap = (canvas.width/2)-1.5
                        }
                        // this.x += canvas.width/2
                        }
                        if(x > (canvas.width/2)+3){
            
                        for(let t =0 ;t<glist.length;t++){
                            glist[t].xleap = -((canvas.width/2)-1.5)
                        }
                        // this.x -= canvas.width/2
                        }
                    if(y <-3){
        
                        ////////console.log(this.immune.length, glist.length)
                        for(let t =0 ;t<glist.length;t++){
                            glist[t].yleap = (canvas.height/2)-1.5
                        }
                        // this.y += canvas.width/2
                        }
                        if(y > (canvas.height/2)+3){
            
                        for(let t =0 ;t<glist.length;t++){
                            glist[t].yleap = -((canvas.height/2)-1.5)
                        }
                        // this.y -= canvas.width/2
                        }
                }
    
    
    
                this.energy = g
                this.pushoutsto = p
                this.age = ag
                this.ll = ll
                // this.pushout = p
    
                // ////////////////////////console.log(this)
                this.hit = 1
                for(let t = 0;t<this.immune.length;t++){
                    globalnodes[this.immune[t]].head = 0
                }
    
    
                
                this.head = 1
    
    
            }
            disconnect(node){
                if(this.superdead == 1){
                    return
                }
                if(this.dcon.includes(node.id)){
                    return
                }
    
                // //////////////////console.log(node, this)
                // if(node.neighbors.includes(globalnodes.indexOf(this))){
                let ni  = node.id
                let nit  = this.id
                    this.neighbors.splice(this.neighbors.indexOf(ni), 1) 
                    node.neighbors.splice(node.neighbors.indexOf(nit), 1)
                    this.stupidneighbors[ni] =0
                    node.stupidneighbors[nit] =0
                // }
                // if(this.neighbors.includes(globalnodes.indexOf(node))){
                    this.neighbors.splice(this.neighbors.indexOf(ni), 1)
                    node.neighbors.splice(node.neighbors.indexOf(nit), 1)
                // }
    
                this.dcon.push(ni)
                node.dcon.push(nit)
                this.dmark = 1
                node.dmark = 1
    
                let supp = 0
                for(let t = 0;t<this.neighbors.length;t++){
                    if(this.neighbors[t] == this.id){
                    }else{
                        supp = 1
                    }
                }
                if(supp == 0){
                    this.head = 1
                }
    
    
    
                let supph = 0
                for(let t = 0;t<node.neighbors.length;t++){
                    if(node.neighbors[t] == node.id){
                    }else{
                        supph = 1
                    }
                }
                if(supph == 0){
                    node.head = 1
                }
    
    
            }
            connect(node) {
                if(this.dead == 1){
                    if(this.firsty != 1){
                        for(let t = 0;t<this.neighbors.length;t++){
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    return
                }
    
                if(globalnodes.indexOf(node) == globalnodes.indexOf(this)){
                    return
                }
                if(this.neighbors.includes(globalnodes.indexOf(node)) || node.neighbors.includes(globalnodes.indexOf(this))){
                    return
                }
    
    
                this.neighbors.push(globalnodes.indexOf(node))
                node.neighbors.push(globalnodes.indexOf(this))
    
                this.stupidneighbors[globalnodes.indexOf(node)] = 1
                node.stupidneighbors[globalnodes.indexOf(this)] = 1
    
                if(this.neighbors.length > 2){
                    ////console.log(this)
                }
    
                return
    
                if (this.type == 6) {
                    this.neighbors.push(globalnodes.indexOf(node))
                    node.neighbors.push(globalnodes.indexOf(this)) 
            }else  if (this.type == 0 || this.type == 3) {
                    if(this.type == 3){
                        if(node.type != 3 && node.type != 1){
    
                            this.neighbors.push(globalnodes.indexOf(node))
                            node.neighbors.push(globalnodes.indexOf(this))
                        }
                    }else{
                
                        this.neighbors.push(globalnodes.indexOf(node))
                        node.neighbors.push(globalnodes.indexOf(this))
                    }
                } else {
                    if (this.type == 1) {
                        if ((this.neighbors.length < 4|| node.type == 6)) {
                            if (node.type != 1 && node.type != 3) {
                                this.neighbors.push(globalnodes.indexOf(node))
                                node.neighbors.push(globalnodes.indexOf(this))
                            }
                        }
                    }
                    if (this.type == 2) {
                        if (this.neighbors.length < 3 || node.type == 6) {
                            if (node.type != 2) {
                                this.neighbors.push(globalnodes.indexOf(node))
                                node.neighbors.push(globalnodes.indexOf(this))
                            }
                        }
                    }
                    if (this.type == 4) {
                        if ((this.neighbors.length < 1|| node.type == 6) && node.type != 4 && node.type != 5) {
                            this.neighbors.push(globalnodes.indexOf(node))
                            node.neighbors.push(globalnodes.indexOf(this)) 
                        }
                    }
                    if (this.type == 5) {
                        if ((this.neighbors.length < 1|| node.type == 6) && node.type != 4) {
                            this.neighbors.push(globalnodes.indexOf(node))
                            node.neighbors.push(globalnodes.indexOf(this)) 
                        }
                    }
        
        
                }
            }
            aged(){
    
    
    
                this.trueage++
    
                let len = this.genestring.split('').length
    
                    if(this.energy > genelengthcost && codonusage == 1){
                        this.energy-=genelengthcost*len
                    }
                    if( codonusage == 1){
                    this.nodeEnergyCost += genelengthcost*len
    
    
                    }
    
                if(this.drag == 1){
                    this.age+=1.25
                    if(this.energy > dragcost){
                        this.energy-=dragcost
                    }
                    this.nodeEnergyCost += dragcost
                }
                
                if(this.life != 1){
                    this.age++
                }else{
                    if(this.energy > longevitycost){
                        this.energy-=longevitycost
                        this.age+=.25
                    }else{
                       this.age++
                    }
    
                    this.nodeEnergyCost += longevitycost
                }
            }
            drive() {
    
                
                if(this.dead == 1){
           
                    if(this.firsty != 1){
                        for(let t = 0;t<this.neighbors.length;t++){
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    return
                }
        
                if(this.energy < .01){
                    // this.age+= 10
                }
                this.hit = 0
                this.fed = 0
                if (this.produce == 1) {
                    if(this.energy < this.gencap){
                        this.energy += (this.generate * Math.random() * 2) //same on a curve
                    }
                }
    
    
                if (this.motor == 1) {
                        if (this.energy >= movementCost) {
                            this.x += Math.cos(this.pushout) *3*worldscaler
                            this.y += Math.sin(this.pushout) *3*worldscaler
                            this.energy-=movementCost
                        }
                            this.nodeEnergyCost += movementCost
                }
                if(edgeLoop !=1){
    
                if(this.x >= canvas.width/2){
                    this.pushout+=Math.PI/(((Math.random()-.5)*4)+.01)
                    // this.pushoutsto = this.pushout
                }
                if(this.y >= canvas.height/2){
                    this.pushout+=Math.PI/(((Math.random()-.5)*4)+.01)
                    // this.pushoutsto = this.pushout
                }
                if(this.x <= 0){
                    this.pushout+=Math.PI/(((Math.random()-.5)*4)+.01)
                    // this.pushoutsto = this.pushout
                }
                if(this.y  <= 0){
                    this.pushout+=Math.PI/(((Math.random()-.5)*4)+.01)
                    // this.pushoutsto = this.pushout
                }
    
            }
            }
            make() {
                let worldscaler = (worldscale/8)
                if(this.dead == 1){
                    this.inert = 1
       
                    if(this.firsty != 1){
                        for(let t = 0;t<this.neighbors.length;t++){
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    // this.x = 999999
                    // this.y = 999999+(Math.random()*100000)
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3*(worldscaler), "#0044FF")
                    }
                    return
                }
    
    
                if(tempon == 1){
                    if(this.anchor != 1){
                        this.x+=((Math.random()-.5)/temperatureInvert)*temperature
                        this.y+=((Math.random()-.5)/temperatureInvert)*temperature
                    }else{
    
                        this.x+=(((Math.random()-.5)/temperatureInvert)*temperature)/100
                        this.y+=(((Math.random()-.5)/temperatureInvert)*temperature)/100
                    }
                }
    
                //temperature proxy
                if (this.type == 15) {
    
                    this.subr = (16*5)+4
                    this.subg = (16*3)+2
                    this.subb = 16
                    this.prime = 53
                    this.drag = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4*(worldscaler), "#543210", 6, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) 
    
    
                }
                if (this.type == 0) {
                    this.prime = 19
                    this.subr = 255
                    this.subg = 255
                    this.subb = 255
                    this.inert = 1
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3*(worldscaler), "#ffffff")
                    if(viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7){
                        this.body =new Polygon(this.x, this.y, 5*(worldscaler), "#ffffff", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                    }
                    if(viewStyle == 1|| viewStyle == 4 || viewStyle == 6|| viewStyle == 5 || viewStyle == 7){
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                    }else{
    
                        this.body.x = this.x
                        this.body.y = this.y
                    }
                }
                if (this.type == 1) {
                    this.subr = 255
                    this.subg = 0
                    this.subb = 128
                    this.prime = 2
                    this.rotor = 1
                    this.armor = 1
                    // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF00aa")
                    // this.body = new Circle(this.x, this.y, 3, "#AA0055")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 4*(worldscaler), "#AA0055", 4, 0, 0, (this.pushout) + Math.PI)
                    }
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                }
                if (this.type == 2) {
                    this.subr = 255
                    this.subg = 255
                    this.subb = 0
                    this.prime = 3
                    this.armor = 1
                    this.motor = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5*(worldscaler), "#ffff00", 3, 0, 0, (this.pushout))
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) 
                }
                if (this.type == 3) {
                    this.subr = 128
                    this.subg = 0
                    this.subb = 255
                    this.prime = 5
                    this.rotor = 1
                    this.motor = 1
                    if(this.firsty != 1){
                        this.firsty = 1
                    // this.body = new Circle(this.x, this.y, 3.5, "#8800ff")
    
                    this.body =new Polygon(this.x, this.y, 5*(worldscaler), "#8800ff", 3, 0, 0, (this.pushout) + Math.PI)
                    if(viewStyle == 1 || viewStyle == 4 || viewStyle == 6|| viewStyle == 5 || viewStyle == 7){
                        this.body =new Polygon(this.x, this.y, 5*(worldscaler), "#8800ff", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                    }
         
                    if(viewStyle == 1|| viewStyle == 4 || viewStyle == 6|| viewStyle == 5 || viewStyle == 7){
    
                        this.body.body.x = this.x
                        this.body.body.y = this.y
                        this.body.angle = (this.pushout) + Math.PI
                        }else{
        
                            this.body.body.x = this.x
                            this.body.body.y = this.y
                            this.body.angle = (this.pushout) + Math.PI
                            // this.body.x = this.x
                            // this.body.y = this.y
                        }
    
                }
                if (this.type == 4) {
                    this.subr = 0
                    this.subg = 255
                    this.subb = 0
                    this.prime = 7
                    this.produce = 1
                    // this.body = new Circle(this.x, this.y, 4, "#00FF00")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5*(worldscaler), "#00FF00", 6, 0, 0, (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
                }
                if (this.type == 5) {
                    this.subr = 255
                    this.subg = 0
                    this.subb = 0
                    this.prime = 23
                    this.armor = 1
                    this.mouth = 1
                    // this.body = new Circle(this.x, this.y, 5, "#FF0000")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5*(worldscaler), "#FF0000", 5, 0, 0,  (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI 
                }
                if (this.type == 6) {
                    this.subr = 255
                    this.subg = 128
                    this.subb = 0
                    this.prime = 11
                    this.armor = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5*(worldscaler), "#FF8800", 4, 0, 0,  (this.pushout) + Math.PI)
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout) + Math.PI
                }
                if (this.type == 7) {
                    this.subr = 0
                    this.subg = 255
                    this.subb = 255
                    this.prime = 13
                    this.produce = 1
                    this.motor = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5*(worldscaler), "#00FFFF", 3, 0, 0,  (this.pushout) )
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
                }
                if (this.type == 8) {
                    this.subr = 0
                    this.subg = 255
                    this.subb = 64
                    this.prime = 17
                    this.produce = 1
                    this.rotor = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5*(worldscaler), "#228844", 4, 0, 0,  (this.pushout) )
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
                }
                if (this.type == 9) {
                    this.subr = 64
                    this.subg = 64
                    this.subb = 255
                    this.prime = 29
                    this.anchor = 1
                    this.produce = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5*(worldscaler), "#4499FF", 5, 0, 0,  (this.pushout) )
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
                }
                if (this.type == 10) {
                    this.subr = 176
                    this.subg = 100
                    this.subb = 140
                    this.prime = 31
                    this.anchor = 1
                    this.armor = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 5*(worldscaler), "#AA5678", 4, 0, 0,  (this.pushout) )
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
                }
                if (this.type == 11) {
                    this.subr = 176
                    this.subg = 176
                    this.subb = 176
                    this.prime = 37
                    this.piston = 1
                    this.produce = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6*(worldscaler), "#AAFFAA", 2, 0, 0,  (this.pushout) )
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
                }
                if (this.type == 12) {
                    this.subr = 176
                    this.subg = 128
                    this.subb = 128
                    this.prime = 41
                    this.piston = 1
                    this.armor = 1
                    // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                    if(this.firsty != 1){
                        this.firsty = 1
                    this.body = new Polygon(this.x, this.y, 6*(worldscaler), "#AA8888", 2, 0, 0,  (this.pushout) )
                }
                this.body.body.x = this.x
                this.body.body.y = this.y
                this.body.angle = (this.pushout)
                }
    
                if (this.type == 13) {
                    this.prime = 43
                    this.subr = 179
                    this.subg = 0
                    this.subb = 179
                    this.inert = 1
                    this.fertile = 1
                    if(this.firsty != 1){ 
                        this.firsty = 1
                    this.body = new Circle(this.x, this.y, 3.5*(worldscaler), "#FF44bb")
                    if(viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7){
                        this.body =new Polygon(this.x, this.y, 5*(worldscaler), "#FF44bb", 3, 0, 0, (this.pushout) + Math.PI)
                    }
                    }
                    if(viewStyle == 1|| viewStyle == 4 || viewStyle == 6|| viewStyle == 5 || viewStyle == 7){
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                    }else{
    
                        this.body.x = this.x
                        this.body.y = this.y
                    }
                }
                if (this.type == 14) {
                    this.prime = 47
                    this.subr = 128
                    this.subg = 0
                    this.subb = 145
                    // this.inert = 1
                    this.life = 1
                    this.produce = 1
                    if(this.firsty != 1){
                        this.firsty = 1
                    // this.body = new Circle(this.x, this.y, 3, "#889900")
                        this.body =new Polygon(this.x, this.y, 5*(worldscaler), "#889900", 5, 0, 0, (this.pushout) + Math.PI)
                    if(viewStyle == 1 || viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7){
                        this.body =new Polygon(this.x, this.y, 5*(worldscaler), "#889900", 5, 0, 0, (this.pushout) + Math.PI)
                    }
                    }
                    if(viewStyle == 1|| viewStyle == 4 || viewStyle == 6|| viewStyle == 5 || viewStyle == 7){
    
                    this.body.body.x = this.x
                    this.body.body.y = this.y
                    this.body.angle = (this.pushout) + Math.PI
                    }else{
    
                        this.body.body.x = this.x
                        this.body.body.y = this.y
                        this.body.angle = (this.pushout) + Math.PI
                        // this.body.x = this.x
                        // this.body.y = this.y
                    }
                }
                this.body.type = this.type 
                if(magnetism > 0){
                    if(this.maghit != 1){
                        this.maghit = 1
                        this.magnet = new CircleFill(this.x, this.y, magnetradius*this.magratio*worldscaler, magnetcolors[(this.charge+1)])
                    }else{
                        this.magnet.x = this.x
                        this.magnet.y = this.y
                    }
                    if(magdisplay == 1){
                        if(this.charge != 0){
                            this.magnet.draw()
                            if(this.energy > magnetcost){
                                this.energy-=magnetcost
                            }
    
                            this.nodeEnergyCost += magnetcost
                        }
                    }else{
                        if(magmindisp == 1){
    
                        }
                    }
                }
    
                if(viewStyle == 4 || viewStyle == 6 || viewStyle == 6){
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].r)},${(globalnodes[(this.shead)].g)},${ (globalnodes[(this.shead)].b)})`
                    if(keysPressed['v']){
                    this.subcolor = `rgb(${(globalnodes[(this.shead)].p)},${(globalnodes[(this.shead)].z)},${ (globalnodes[(this.shead)].q)})`
                    }
                    if(keysPressed['w']){
                        this.subcolor = `rgb(${(globalnodes[(this.shead)].m)},${(globalnodes[(this.shead)].p)},${ (globalnodes[(this.shead)].z)})`
                    }
                    if(keysPressed['z']){
                        this.subcolor = `rgb(${(globalnodes[(this.shead)].z)},${(globalnodes[(this.shead)].r)},${ (globalnodes[(this.shead)].m)})`
                    }
    
                    if(keysPressed['2']){
                        this.subcolor = `rgb(${(globalnodes[(this.shead)].g)},${(globalnodes[(this.shead)].b)},${ (globalnodes[(this.shead)].q)})`
                    }
    
    
                    if(viewStyle == 6){
                        this.subcolor = `rgb(${(globalnodes[(this.shead)][viewrota[rota%viewrota.length]])},${(globalnodes[(this.shead)][viewrota[(rota+1)%viewrota.length]])},${ (globalnodes[(this.shead)][viewrota[(rota+2)%viewrota.length]])})`
    
                    }
    
    
                    this.body.parent = this
                    this.parent = this
                }
                if(viewStyle == 5 || viewStyle == 7){
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].r*3) + this.subr)/4)},${(((globalnodes[(this.shead)].g*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].b*3)+ this.subb)/4})`
                    if(keysPressed['v']){
                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].p*3) + this.subr)/4)},${(((globalnodes[(this.shead)].z*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].q*3)+ this.subb)/4})`
                        }
                        if(keysPressed['w']){
                            this.subcolor = `rgb(${(((globalnodes[(this.shead)].m*3) + this.subr)/4)},${(((globalnodes[(this.shead)].p*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].z*3)+ this.subb)/4})`
                                }
    
                                
                        if(keysPressed['z']){
                            this.subcolor = `rgb(${(((globalnodes[(this.shead)].z*3) + this.subr)/4)},${(((globalnodes[(this.shead)].r*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].m*3)+ this.subb)/4})`
                                }
                                if(keysPressed['2']){
                                    this.subcolor = `rgb(${(((globalnodes[(this.shead)].g*3) + this.subr)/4)},${(((globalnodes[(this.shead)].b*3) + this.subg)/4)},${ ((globalnodes[(this.shead)].q*3)+ this.subb)/4})`
                                        }
    
    
                                       if(viewStyle == 7){
                                        this.subcolor = `rgb(${(((globalnodes[(this.shead)][viewrota[rota%viewrota.length]]*3) + this.subr)/4)},${(((globalnodes[(this.shead)][viewrota[(rota+1)%viewrota.length]]*3) + this.subg)/4)},${ ((globalnodes[(this.shead)][viewrota[(rota+2)%viewrota.length]]*3)+ this.subb)/4})`
                                  
                                       }
                    this.body.parent = this
                    this.parent = this
                }
    
    
    
    
    
    
    
                // if(tempon == 1){
                //     if(this.anchor != 1){
                //         this.x+=((Math.random()-.5)/temperatureInvert)*temperature
                //         this.y+=((Math.random()-.5)/temperatureInvert)*temperature
                //     }else{
    
                //         this.x+=(((Math.random()-.5)/temperatureInvert)*temperature)/100
                //         this.y+=(((Math.random()-.5)/temperatureInvert)*temperature)/100
                //     }
                // }
    
                //temperature proxy
                // if(this.age > maxage*.1){
                //     this.x+=(Math.random()-.5)/100
                //     this.y+=(Math.random()-.5)/100
                //     if(this.age > maxage*.5){
                //         this.x+=(Math.random()-.5)/50
                //         this.y+=(Math.random()-.5)/50
                //         if(this.age > maxage*.9){
                //             this.x+=(Math.random()-.5)*.04
                //             this.y+=(Math.random()-.5)*.04
                //         }
                //     }
                // }
    
                if(edgeLoop !=1){
    
                this.x = Math.max(0, this.x)
                this.x = Math.min(canvas.width/2, this.x)
                this.y = Math.max(0, this.y)
                this.y = Math.min(canvas.height/2, this.y)
    
                }
                // if(this.x > canvas.width*.5){
                //     this.x = 0
                // }
                // if(this.x < 0){
                //     this.x =  canvas.width*.5
                // }
                // if(this.y > canvas.width*.5){
                //     this.y = 0
                // }
                // if(this.y < 0){
                //     this.y =  canvas.width*.5
                // }
            }
            drawBody() {
                if(this.anchor == 1){
                if (this.energy >= anchorcost) {
    
                        this.energy -= anchorcost
                    }
                    this.nodeEnergyCost += anchorcost
    
                }
                if (this.energy >= baseCostOfNode) {
                    if(this.inert != 1){
                        this.energy-=baseCostOfNode
                    }
                }
                if(this.fertile == 1){
                    if(this.energy >= fertilitycost){
                        this.energy-=fertilitycost
                        this.energy*=fertilityratio
                    }
                }
                if(this.fertile == 1){
                    this.nodeEnergyCost += fertilitycost
                }
    
                if(this.inert != 1){
                    this.nodeEnergyCost += baseCostOfNode
                }
                if(this.mouth == 1){
                if (this.energy >= mouthCost) {
                        this.energy-=mouthCost
                    }
    
                    this.nodeEnergyCost += mouthCost
                }
                    if(this.energy < 0){
                        this.energy  = 0
                    }
                
                if(this.dead == 1){
          
                    if(this.firsty != 1){
                        for(let t = 0;t<this.neighbors.length;t++){
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    return
                }
        
                if(magnetonly == 1){
    
                }else{
                    this.body.draw()
                }
                bodc++
            }
            time() {
                if(this.dead == 1){
                    if(this.firsty != 1){
                        for(let t = 0;t<this.neighbors.length;t++){
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    return
                }
    
                this.caught = 0
                for (let t = 0; t < this.times.length; t++) {
                    if(this.energy >= baseCostOfNode){
                        this.ticks[t] += this.subticks[t]
                    }
                }
                for (let t = 0; t < this.times.length; t++) {
                    if(this.energy >= baseCostOfNode){
                        this.times[t] += Math.cos(this.ticks[t])*this.subrots[t]
                    }
                }
                for (let t = 0; t < this.pistontimes.length; t++) {
                    if(this.energy >= baseCostOfNode){
                        this.pistontimes[t] += this.pistonticks[t]
                    }
                }
            }
    
    
            push(){
                // this.pushoutsto = this.pushout
            }
    
    
            indexkill(index) {
                if (this.id < index) {} else if (this.id == index) {} else {
                    this.id--
                } 
                if (this.shead < index) {} else if (this.shead == index) {} else {
                    this.shead--
                } 
                for (let t = 0; t < this.neighbors.length; t++) {
                    if (this.neighbors[t] < index) {} else if (this.neighbors[t] == index) {
                        //////////////console.log("h")
                        // this.neighbors.splice(t,1)
                        //console.log(this)
                        this.dead = 1
                    } else {
                        this.neighbors[t]--
                    }
                }
                for (let t = 0; t < this.link.list.length; t++) {
                    // ////////////////console.log(this.link.list[t], index)
                    if (this.link.list[t] < index) {} else if (this.link.list[t] == index) {
                        //////////////console.log("i")
                        // this.link.list.splice(t,1)
                    } else {
                        this.link.list[t]--
                    }
                }
                // ////////////console.log(this.neighbors)
                this.stupidneighbors = []
                for (let t = 0; t < this.neighbors.length; t++) {
                    this.stupidneighbors[this.neighbors[t]] = 1
                }
        
        
                for (let t = 0; t < this.immune.length; t++) {
                    // ////////////////console.log(this.link.list[t], index)
                    if (this.immune[t] < index) {} else if (this.immune[t] == index) {
                        //////////////console.log("r")
                        // this.immune.splice(t,1)
                    } else {
                        this.immune[t]--
                    }
                }
        
        
                this.stupidimmune = []
                for (let t = 0; t < this.immune.length; t++) {
                    this.stupidimmune[this.immune[t]] = 1
                }
        
        
            }
    
            makeRotation() {
                if(this.dead == 1){
                    if(this.firsty != 1){
                        for(let t = 0;t<this.neighbors.length;t++){
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    return
                }
                let z = 0
                // // this.link.list = []
                // if(this.linkup.length == 2){
                //     //console.log(this)
                // }
    
    
                if(this.rotor != 1){
                    return
                }
    
                // if(this.piston == 1){
                //     if(this.energy >= pistoncost){
                //         this.energy-=pistoncost
    
                //         this.pistontime+=this.pistonstep
    
                //         this.pistonpush += (Math.sin(this.pistontime)/1)
                //         this.pistonpush = Math.min(this.pistonpush, 12)
                //         this.pistonpush = Math.max(this.pistonpush, -12)
    
                //     }
                // }
    
    
                for (let t = 0; t < this.neighbors.length; t++) {
                    // //////////////console.log()
                    if(this.dead == 1){
                        break
                    }
                    let nd = globalnodes[this.neighbors[t]]
                    if(!nd){
                        ////////////console.log(globalnodes, this.neighbors[t])
                        continue
                    }
                    if(nd.dead == 1){
                        continue
                    }  
                    // if (this.stupidneighbors[t] == 1) {
                 
                        this.link.target = nd
                        let j = 0
                        let lf = (((this.lout+this.pistonpushes[z])+(nd.lout+nd.pistonpushes[z]))/2)
                        // let mes = this.link.hypotenuse()
                        // let a = this.link.angle()
        
        
                        if (this.rotor == 1) {
                            this.lt.x = this.x + (Math.cos(((this.times[z]))) * lf)
                            this.lt.y =  this.y + (Math.sin(this.times[z]) * lf)
                                if (this.energy >= rotationCost) {
                                    this.energy-=rotationCost
                                    if(this.link.target.anchor != 1){
                                        this.link.target.x = (this.link.target.x * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.x)
                                        this.link.target.y = (this.link.target.y * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.y)
                                    }else{
    
                                    this.link.target.x = (this.link.target.x * (1 - (this.rigs[z]/100))) + ((this.rigs[z]/100) * this.lt.x)
                                    this.link.target.y = (this.link.target.y * (1 - (this.rigs[z]/100))) + ((this.rigs[z]/100) * this.lt.y)
        
                                    }
                                    // if (this.type == 1 || this.type == 3) { 
                                            nd.pushout = nd.pushoutsto + this.times[z]
                                            // this.pushout = this.pushoutsto - this.times[z]
                                    // }
                                } else {
        
                                }
        
    
                    this.nodeEnergyCost += rotationCost
                        }
                        // globalnodes[t].link.list.push(globalnodes.indexOf(this))
                    // }
                }
    
    
        
            }
            makePiston() {
                if(this.dead == 1){
                    if(this.firsty != 1){
                        for(let t = 0;t<this.neighbors.length;t++){
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    return
                }
                let z = 0
    
                if(this.piston != 1){
    
                    for (let t = 0; t < timesLength; t++) {
                        this.pistonpushes[t] = 0
                    }
                    return
                }
    
    
                for (let t = 0; t < this.neighbors.length; t++) {
                    // //////////////console.log()
                    if(this.dead == 1){
                        break
                    }
                    let nd = globalnodes[this.neighbors[t]]
                    if(!nd){
                        continue
                    }
                    if(nd.dead == 1){
                        continue
                    }  
                 
                        this.link.target = nd
    
    
                        if(this.piston == 1){
                            if(this.energy >= pistoncost){
                                this.energy-=pistoncost
                                this.pistonpushes[z] += (Math.sin(this.pistontimes[z]+this.pistonstarts[z])/1)
                                this.pistonpushes[z] = Math.min(this.pistonpushes[z], ((loutmin*worldscaler)*3))
                                this.pistonpushes[z] = Math.max(this.pistonpushes[z], -((loutmin*worldscaler)/2))
                            }
                            this.nodeEnergyCost += pistoncost
                        }
            
    
    
    
                        z++
                        z %= this.las.length
    
        
                        this.link.mark = 1
                        this.link.list.push(this.neighbors[t])
                        nd.link.mark = 1
                        nd.link.list.push(globalnodes.indexOf(this))
    
    
                        this.xleap = (Math.abs(this.xleap) > Math.abs(nd.xleap) ? this.xleap:nd.xleap)
                        this.yleap = (Math.abs(this.yleap) > Math.abs(nd.yleap) ? this.xleap:nd.yleap)
                }
    
    
        
            }
            makeLink() {
                if(this.dead == 1){
                    if(this.firsty != 1){
                        for(let t = 0;t<this.neighbors.length;t++){
                            this.disconnect(globalnodes[this.neighbors[t]])
                        }
                    }
                    return
                }
                let z = 0
                this.link.list = []
                if(this.linkup.length == 2){
                    //console.log(this)
                }
    
    
                // if(this.piston == 1){
                //     if(this.energy >= pistoncost){
                //         this.energy-=pistoncost
    
                //         this.pistontime+=this.pistonstep
    
                //         this.pistonpush += (Math.sin(this.pistontime)/1)
                //         this.pistonpush = Math.min(this.pistonpush, 12)
                //         this.pistonpush = Math.max(this.pistonpush, -12)
    
                //     }
                // }
    
    
                for (let t = 0; t < this.neighbors.length; t++) {
                    // //////////////console.log()
                    if(this.dead == 1){
                        break
                    }
                    let nd = globalnodes[this.neighbors[t]]
                    if(!nd){
                        ////////////console.log(globalnodes, this.neighbors[t])
                        continue
                    }
                    if(nd.dead == 1){
                        continue
                    }  
                    // if (this.stupidneighbors[t] == 1) {
                 
                        this.link.target = nd
                        let j = 0
                        let lf = (((this.lout+this.pistonpushes[z])+(nd.lout+nd.pistonpushes[z]))/2)
                        let mes = this.link.hypotenuse()
                        let a = this.link.angle()
                        // while (mes > lf) {
                        //     j++
                        //     if(j>20){
                        //         break
                        //     }
                        //     let outs = 0
                        //     if(this.anchor != 1){
                        //         this.x -= Math.cos(a) * 1.2
                        //         this.y -= Math.sin(a) * 1.2
                        //         outs+=1.2
                        //     }else{
                        //         if(this.link.target.anchor != 1){
                        //     this.x -= Math.cos(a) * .012
                        //     this.y -= Math.sin(a) * .012
                        //     outs+=.012
                        //         }else{
                        //             this.x -= Math.cos(a) * .06
                        //             this.y -= Math.sin(a) * .06
                        //             outs+=.06
                        //         }
                        //     }
                        //     if(this.link.target.anchor != 1){
                        //     this.link.target.x += Math.cos(a) * 1.2
                        //     this.link.target.y += Math.sin(a) * 1.2
                        //     outs+=1.2
                        //     }else{
    
                        //         if(this.anchor != 1){
                        //     this.link.target.x += Math.cos(a) * .012
                        //     this.link.target.y += Math.sin(a) * .012
                        //     outs+=.012
                        //         }else{
                        //             this.link.target.x += Math.cos(a) * .06
                        //             this.link.target.y += Math.sin(a) * .06
                        //             outs+=.06
    
                        //         }
                                
                        //     }
                        //     mes-=outs
                        // }
                        j = 0
                        while (mes > lf) {
                            j++
                            if(j>10){
                                break
                            }
    
                            let outs = 0
                            if(this.anchor != 1){
                            this.x -= Math.cos(a) * .8 * worldscaler
                            this.y -= Math.sin(a) * .8 * worldscaler
                            outs+=.8 * worldscaler
                            }else{
    
                                if(this.link.target.anchor != 1){
                            this.x -= Math.cos(a) * .008 * worldscaler
                            this.y -= Math.sin(a) * .008 * worldscaler
                            outs+=.008
                                }else{
    
                                    this.x -= Math.cos(a) * .04 * worldscaler
                                    this.y -= Math.sin(a) * .04 * worldscaler
                                    outs+=.04 * worldscaler
    
                                }
                            }
                            if(this.link.target.anchor != 1){
                            this.link.target.x += Math.cos(a) * .8 * worldscaler
                            this.link.target.y += Math.sin(a) * .8 * worldscaler
                            outs+=.8
                            }else{
                                if(this.anchor != 1){
                                this.link.target.x += Math.cos(a) * .008 * worldscaler
                                this.link.target.y += Math.sin(a) * .008 * worldscaler
                                outs+=.008 * worldscaler
                                }else{
    
                                    this.link.target.x += Math.cos(a) * .04 * worldscaler
                                    this.link.target.y += Math.sin(a) * .04 * worldscaler
                                    outs+=.04 * worldscaler
    
                                }
    
                            }
                            mes-=outs*.999
                        }
    
    
    
    
    
    
                        j = 0
                        while (mes < lf) {
                            j++
                            if(j>10){
                                break
                            }
    
                            let outs = 0
                            if(this.anchor != 1){
                            this.x += Math.cos(a) * .8 * worldscaler
                            this.y += Math.sin(a) * .8 * worldscaler
                            outs-=.8 * worldscaler
                            }else{
    
                                if(this.link.target.anchor != 1){
                            this.x += Math.cos(a) * .008 * worldscaler
                            this.y += Math.sin(a) * .008 * worldscaler
                            outs-=.008 * worldscaler
                                }else{
    
                                    this.x += Math.cos(a) * .04 * worldscaler
                                    this.y += Math.sin(a) * .04 * worldscaler
                                    outs-=.04 * worldscaler
    
                                }
                            }
                            if(this.link.target.anchor != 1){
                            this.link.target.x -= Math.cos(a) * .8 * worldscaler
                            this.link.target.y -= Math.sin(a) * .8 * worldscaler
                            outs-=.8 * worldscaler
                            }else{
                                if(this.anchor != 1){
                                this.link.target.x -= Math.cos(a) * .008 * worldscaler
                                this.link.target.y -= Math.sin(a) * .008 * worldscaler
                                outs-=.008 * worldscaler
                                }else{
    
                                    this.link.target.x -= Math.cos(a) * .04 * worldscaler
                                    this.link.target.y -= Math.sin(a) * .04 * worldscaler
                                    outs-=.04 * worldscaler
    
                                }
    
                            }
                            mes-=outs*.998
                        }
    
    
        
                        // this.lt.x = this.x + (Math.cos(((this.times[z]))) * this.lout)
                        // this.lt.y =  this.y + (Math.sin(this.times[z]) * this.lout)
        
        
                        // // let easedp = new Point((this.link.target.x*(1-this.rigs[z])) + (lt.x*this.rigs[z]),    (this.link.target.y*(1-this.rigs[z])) + (lt.y*this.rigs[z]))
        
                        // //
        
        
        
                        // if (this.rotor == 1) {
                        //         if (this.energy >= rotationCost) {
                        //             this.energy-=rotationCost
                        //             if(this.link.target.anchor != 1){
                        //                 this.link.target.x = (this.link.target.x * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.x)
                        //                 this.link.target.y = (this.link.target.y * (1 - this.rigs[z])) + (this.rigs[z] * this.lt.y)
                        //             }else{
    
                        //             this.link.target.x = (this.link.target.x * (1 - (this.rigs[z]/10))) + ((this.rigs[z]/10) * this.lt.x)
                        //             this.link.target.y = (this.link.target.y * (1 - (this.rigs[z]/10))) + ((this.rigs[z]/10) * this.lt.y)
        
                        //             }
                        //             // if (this.type == 1 || this.type == 3) { 
                        //                     nd.pushout = nd.pushoutsto + this.times[z]
                        //                     // this.pushout = this.pushoutsto - this.times[z]
                        //             // }
                        //         } else {
        
                        //         }
        
                        // }
        
        
                        z++
                        z %= this.las.length
        
                        if(this.energy >= linkcost){
                            this.energy-=linkcost/2
                        }
                        if(this.energy >= linkcostdistance*this.lout){
    
    
                            this.energy -= linkcostdistance*this.lout
                        }
        
                        this.nodeEnergyCost += linkcost/2
                        this.nodeEnergyCost += linkcostdistance*this.lout
                        this.energy = Math.max(this.energy, 0)
    
    
                        this.link.mark = 1
                        this.link.list.push(this.neighbors[t])
                        nd.link.mark = 1
                        nd.link.list.push(globalnodes.indexOf(this))
    
    
                        this.xleap = (Math.abs(this.xleap) > Math.abs(nd.xleap) ? this.xleap:nd.xleap)
                        this.yleap = (Math.abs(this.yleap) > Math.abs(nd.yleap) ? this.xleap:nd.yleap)
    
                        // globalnodes[t].link.list.push(globalnodes.indexOf(this))
                    // }
                }
    
    
        
            }
            dying(){
    
                if(deadwash < 3 || deadwash > deadmax-3){
                    return
                }
                if(this.trueage > 2){
                    if(this.neighbors.length <= 1){
                        this.head = 1
                    }
                }
    
                if(this.die == 1){
                    //////console.log(this.neighbors, this)
                    if(this.trueage > 5) {
                    this.head = 1
                    this.dead = 1
                    }
                }
    
                if(this.cut == 1){
                    this.die = 1
                }
    
    
                if (this.mouth == 1) {
                    if (this.link.list.length == 0 && this.immune.length <= 2 && this.trueage > 5) {
                        this.dead = 1
                    }
        
                    let alldead = 0
                    for (let t = 0; t < globalnodes.length; t++) {
                        if (globalnodes[t].dead == 1) {
                            alldead++
                        }
                    }
        
                    if (this.balanced == 1) {
        
                        if ((this.age > Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin)) || (this.immune.length <= 2)) {
                            //////////////console.log(((this.ll)*(this.ll))*Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin), this.ll)
                            if (this.immune.length <= 2 || this.age > (((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin)) {
                                this.dead = 1
                                if (totalKill == 1) {
                                    if (totalKill == 1) {
                                        for (let d = 0; d < this.immune.length; d++) {
                                            globalnodes[this.immune[d]].dead = 1
                                        }
                                    }
                                }
                            }
                        }
        
                    }
        
        
                } else {
        
        
                    if (this.link.list.length == 0 && this.immune.length <= 2  && this.trueage > 5) {
                        this.dead = 1
                    }
                    let alldead = 0
                    for (let t = 0; t < globalnodes.length; t++) {
                        if (globalnodes[t].dead == 1) {
                            alldead++
                        }
                    }
        
                    if (this.balanced == 1) {
        
                        if ((this.age > Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin)) || (this.immune.length <= 2)) {
                            //////////////console.log(((this.ll)*(this.ll))*Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin), this.ll)
                            if (this.immune.length <= 2 || this.age > (((this.ll / 1.25) * (this.ll / 1.25))) * Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin)) {
                                this.dead = 1
                                if (totalKill == 1) {
                                    if (totalKill == 1) {
                                        for (let d = 0; d < this.immune.length; d++) {
                                            globalnodes[this.immune[d]].dead = 1
                                        }
                                    }
                                }
                            }
                        }
        
                    }
                }
                    
            }
            text(){
    
                if(this.dead == 1){
                    return
                }
    
                if(!keysPressed['h'] && !keysPressed['e'] && !keysPressed['r'] &&  !keysPressed['c'] && !keysPressed['b'] &&!keysPressed['l']){
    
                    return
                }else if(keysPressed['l']){
    
                    canvas_context.fillStyle = "white"
                    canvas_context.lineWidth = 1
                    canvas_context.strokeStyle = "black"
                    canvas_context.font = "10px arial"
        
                    // this.energy = Math.round(this.energy*100)/100
    
                    if(this.head == 1){
                        canvas_context.strokeText(Math.round(this.energyOrgCost*10000), this.xavg-5, this.yavg+2)
                        canvas_context.fillText(Math.round(this.energyOrgCost*10000), this.xavg-5, this.yavg+2)
                    }
        
    
                }else if(keysPressed['b']){
                    canvas_context.fillStyle = "white"
                    canvas_context.lineWidth = 1
                    canvas_context.strokeStyle = "black"
                    canvas_context.font = "12px arial"
        
                    // this.energy = Math.round(this.energy*100)/100
    
                    let c = 0
                    for(let t = 0;t<this.genebucket.length;t++){
                        c += (this.genebucket[t].split('')).length
                    }
        
        
                    if(this.head == 1){
                        canvas_context.strokeText(c, this.xavg-5, this.yavg+2)
                        canvas_context.fillText(c, this.xavg-5, this.yavg+2)
                    }
        
                }else if(keysPressed['c'] && keysPressed['h']){
                    canvas_context.fillStyle = "white"
                    canvas_context.lineWidth = 1
                    canvas_context.strokeStyle = "black"
                    canvas_context.font = "8px arial"
        
                    // this.energy = Math.round(this.energy*100)/100
        
        
                    if(this.head == 1){
                        canvas_context.strokeText(this.genestring, this.xavg, this.yavg)
                        canvas_context.fillText(this.genestring, this.xavg, this.yavg)
                    }
        
                }else if(keysPressed['c']){
                    canvas_context.fillStyle = "white"
                    canvas_context.lineWidth = 1
                    canvas_context.strokeStyle = "black"
                    canvas_context.font = "8px arial"
        
                    // this.energy = Math.round(this.energy*100)/100
        
        
                        canvas_context.strokeText(this.genestring, this.x, this.y)
                        canvas_context.fillText(this.genestring, this.x, this.y)
        
                 }else if(keysPressed['h']){
    
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = "10px arial"
    
                // this.energy = Math.round(this.energy*100)/100
    
                if(this.head == 1){
    
                    canvas_context.strokeText(Math.round((this.energy/((repconstant*((((this.m)))))))*100) +"%", this.xavg, this.yavg)
                    canvas_context.fillText(Math.round((this.energy/((repconstant*((((this.m)))))))*100) +"%", this.xavg, this.yavg)
                }
                }else if(keysPressed['e']){
                    canvas_context.fillStyle = "white"
                    canvas_context.lineWidth = 1
                    canvas_context.strokeStyle = "black"
                    canvas_context.font = "10px arial"
        
                    let alldead = 0
                    for(let t = 0;t<globalnodes.length;t++){
                        if(globalnodes[t].dead ==1){
                            alldead++
                        }
                    }
                    if(this.head == 1){
                    this.age = Math.round(this.age*100)/100  
                    canvas_context.strokeText(Math.round(100*(this.age/((((this.ll/1.25)*(this.ll/1.25)))*Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin)))) +"%",this.xavg, this.yavg)
                    canvas_context.fillText(Math.round(100*(this.age/((((this.ll/1.25)*(this.ll/1.25)))*Math.max(((maxage - minage) - (globalnodes.length - alldead)),timemin)))) +"%",this.xavg, this.yavg)
                    }
                }else if(keysPressed['r']){
                    canvas_context.fillStyle = "white"
                    canvas_context.lineWidth = 1
                    canvas_context.strokeStyle = "black"
                    canvas_context.font = "11px arial"
        
                    // this.age = Math.round(this.age*100)/100
            
                    if(this.head == 1){
                    canvas_context.strokeText(this.ll, this.xavg, this.yavg)
                    canvas_context.fillText(this.ll, this.xavg, this.yavg)
                    }
                }
            }
        }
        
        let globalnodes = []
        
    
        let nodein = []
    
        // for(let t = 0;t<2;t++){
        //     let node = new Node(Math.random()*canvas.width,Math.random()*canvas.height, nodein[t])
        //     if(Math.random() <1){
        //         node.connect(globalnodes[Math.floor(Math.random()*globalnodes.length)])
        //     }
        //   }
        // //   for(let t = 0;t<50;t++){
        // //       let node = new Node(360+ (Math.random()*80),360+ (Math.random()*80), Math.floor(Math.random()*6))
        // //       if(Math.random() <.8){
        // //           node.connect(globalnodes[Math.floor(Math.random()*globalnodes.length)])
        // //       }
        // //     }
        // //   for(let t = 0;t<2;t++){
        // //     let node = new Node(Math.random()*canvas.width,Math.random()*canvas.height, 4)
        // //     if(Math.random() <.2){
        // //         node.connect(globalnodes[Math.floor(Math.random()*globalnodes.length)])
        // //     }
        // //   }
        
        //   for(let t = 0;t<10;t++){
        //     globalnodes[Math.floor(Math.random()*globalnodes.length)].connect(globalnodes[Math.floor(Math.random()*globalnodes.length)])
        //   }
    
    
    
        function init(nodein){
    
    
            if(makeall == 1){
    
                runcount = 1000
            }else{
    
                for(let t = 0;t<nodein.length;t++){
    
                    let genes = ""
                    if(nodein[t] == 15){
                        let jump = Math.floor(Math.random()*geneChars.length)
                        for(let r = 0;r<genelength;r++){
                            genes+=geneChars[(nodein[t]+r+jump)%(geneChars.length)]
                        }
                    }else{
    
                        let jump = Math.floor(Math.random()*geneChars.length)
                        for(let r = 0;r<2;r++){
                            genes+=geneChars[nodein[t]]
                        }
                        for(let r = 0;r<genelength-2;r++){
                            genes+=geneChars[(nodein[t]+r+jump)%(geneChars.length)]
                        }
    
                    }
    
    
                    let node = new Node(canvas.width/4,(canvas.height/4), nodein[t], genes)
                    if(t == 0){
                        node.head = 1
                    }
                    if(Math.random() <1){
                        node.connect(globalnodes[Math.floor(Math.random()*globalnodes.length)])
                    }
                  }
                  for(let t = 0;t<nodein.length;t++){
                    let f = Math.floor(Math.random()*globalnodes.length)
                    let g = Math.floor(Math.random()*globalnodes.length)
                    if(f != g){
                        if( globalnodes[f].neighbors.length < 3 && globalnodes[g].neighbors.length < 3){
            
                            globalnodes[f].connect(globalnodes[g])
                        }
            
                    }else{
                        t--
                    }
                  }
            }
    
    
    
    
          if(makeall == 1){
    
            for(let t = 0;t<nodetypes;t++){
                for(let k = t;k<nodetypes;k++){
    
    
    
                    let genest = ""
                    for(let r = 0;r<genelength;r++){
                        genest+=geneChars[t]
                    }
    
                    let genesk = ""
                    for(let r = 0;r<genelength;r++){
                        genesk+=geneChars[k]
                    }
    
    
    
                    let node = new Node(30+(30*(k)), 30+(30*t), k, genesk)
                    let nud = new Node(30+(30*(k)), 30+(30*t), t, genest)
    
                    node.head = 1
                        nud.connect(node)
                }
            }
    
    
    
          }else if(makegreen == 1){
     
            for(let t = 0;t<15;t++){
                if(greens.includes(t)){
    
                    let genest = ""
                    for(let r = 0;r<genelength;r++){
                        genest+=geneChars[t]
                    }
    
                    let genes4 = ""
                    for(let r = 0;r<genelength;r++){
                        genes4 +=geneChars[4]
                    }
    
                    let node = new Node(100+(100*(t%4)), 100+(100*Math.floor(t/4)), 4, genes4)
                    let nud = new Node(100+(100*(t%4)), 100+(100*Math.floor(t/4)), t,genest)
        
                    node.head = 1
                        nud.connect(node)
                }
            
            }
    
          }
    
    
          if(ringon == 1){
    
            let ringsize = 40
            let a = (Math.PI/ringsize)*2
      
          for(let t = 0;t<ringsize;t++){
      
    
            let genest = ""
            for(let r = 0;r<genelength;r++){
                genest+=geneChars[t]
            }
    
            let genes4 = ""
            for(let r = 0;r<genelength;r++){
                genes4 +=geneChars[6]
            }
    
    
              let node = new Node((canvas.width/4)+(Math.cos(a*t)*ringsize*2),(canvas.height/4)+(Math.sin(a*t)*ringsize*2), 6, genes4)
              if(makeline ==1){
    
                // node.type = 5
                node.charge = -1
                node.magratio = Math.random()*2.5
              }
    
    
              if(t == 0){
                  node.head = 1
              }
              if(t > 0){
                  globalnodes[t-1+nodein.length].connect(node)
              }
          }
          if(makeline == 1){
    
          }else{
    
            globalnodes[0+nodein.length].connect(globalnodes[globalnodes.length-1])
          }
      
          for(let t = 0;t<ringsize;t++){
            let genes4 = ""
            for(let r = 0;r<genelength;r++){
                genes4 +=geneChars[5]
            }
    
              let node = new Node((canvas.width/4)+(Math.cos(a*t)*ringsize*2.2),(canvas.height/4)+(Math.sin(a*t)*ringsize*2.2), 5, genes4)
         
              if(makeline ==1){
    
                node.charge = 1
                node.magratio = Math.random()*2.5
              }
                  globalnodes[(t*1)+nodein.length].connect(node)
                  if(t > 0){
                      globalnodes[t-1+nodein.length].connect(node)
                  }
      
                  if(t > 0){
                      globalnodes[t-1+nodein.length + ringsize].connect(node)
                  }
      
      
          }
          if(makeline == 1){
    
          }else{
    
          globalnodes[nodein.length + ringsize].connect(globalnodes[globalnodes.length-1])
          globalnodes[nodein.length + ringsize].connect(globalnodes[globalnodes.length-(ringsize +1)])
          }
      
      
          }
    
        }
        //   let nodem = new Node(360,360, 5)
        //   nodem.connect(globalnodes[Math.floor(Math.random()*globalnodes.length)])
        // //   nodem.connect(globalnodes[Math.floor(Math.random()*globalnodes.length)])
          
        
        //   for(let t = 0;t<globalnodes.length;t++){
    
        //     if(globalnodes[t].neighbors.length == 0){
        //         // globalnodes.splice(t,1)
        //         // t--
        //         // globalnodes[t].dead = 1
    
        //     }
        //   }
        
        // let nod1 = new Node(100, 100, 0)
        // let nod2 = new Node(110, 100, 0)
        // let nod3 = new Node(130, 100, 0)
        // let nod4 = new Node(140, 100, 1)
        // let nod5 = new Node(140, 100, 2)
        // let nod6 = new Node(160, 100, 0)
        // let leaf1 = new Node(110, 110, 4)
        // let leaf2 = new Node(110, 90, 4)
        // let leaf3 = new Node(120, 110, 4)
        // let leaf4 = new Node(120, 90, 4)
        // let leaf5 = new Node(120, 90, 4)
        
        // let push1 = new Node(90, 100, 2)
        // let push2 = new Node(690, 100, 2)
        // let push3 = new Node(90, 100, 2)
        // let push4 = new Node(90, 100, 2)
        // let pivot1 = new Node(120, 100, 0)
        // let pivot3 = new Node(420, 400, 1)
        // let pivot2 = new Node(120, 100, 1)
        // let pivot3 = new Node(120, 100, 1)
        // let pivot4 = new Node(120, 100, 1)
        
        
        // globalnodes.push(nod1, nod2, nod3, leaf1, leaf2, push1, pivot1)
        
        
        // for(let t = 0;t<globalnodes.length;t++){
    
        //     if(globalnodes[t].neighbors.length == 0){
        //         // globalnodes[t].dead = 1
        //     }
        //   }
        
        
          canvas_context.imageSmoothingEnabled = true
      
    
          let instructions = []
    
          instructions.push("Structural node: No cost, no special value, just structure.")
          instructions.push("Rotation node: Low cost, rotational value. Turns other components. Cant be eaten.")
          instructions.push("Head node: Medium cost, propulsion value, armor value. Pulls other components and cannot be eaten.")
          instructions.push("Rotational head node: High cost, propulsion value, rotation value. Pulls other components and rotates other components.")
          instructions.push("Production node: High energy production. Energy is needed for replication of any components.")
          instructions.push("Tooth node:  Medium cost, eats other components. Gain energy as a predator, cannot be eaten.")
          instructions.push("Armor node: Low cost, blocks other components. cannot be eaten.")
          instructions.push("Production motor node: Moderate energy production,  Pulls components.")
          instructions.push("Production rotor node: Moderate energy production,  Rotates components.")
          instructions.push("Production anchor node: Produces energy, Holds fast.")
          instructions.push("Armored anchor node: Medium cost, Holds fast. cannot be eaten.")
          instructions.push("Generator Piston node: Generate energy, Pushes components.")
          instructions.push("Armored piston node: Medium cost, Pushes components. Can't be eaten.")
          instructions.push("Reproduction node: Inverse cost, reduces time to reproduce.")
          instructions.push("Longevity node: Produces some energy, increases lifespan.")
          instructions.push("Disease node: Consumes some energy, decreases lifespan.")
    
    
    
    
    
    
          class Toggle {
            constructor(x, y, initial, onChange) {
                this.x = x-160
                this.y = y;
                this.width = 40;
                this.height = 20;
                this.state = initial; // true or false
                this.onChange = onChange;
            }
        
            draw(label) {
                // Label
                canvas_context.fillStyle = '#FFF';
                canvas_context.font = '14px Arial';
                canvas_context.fillText(label, this.x - 0, this.y -10);
        
                // Background
                canvas_context.fillStyle = this.state == 1 ? '#0f0' : '#800';
                canvas_context.fillRect(this.x, this.y, this.width, this.height);
        
                // Thumb
                const thumbX = this.x + (this.state == 1? this.width - this.height : 0);
                canvas_context.fillStyle = '#FFF';
                canvas_context.beginPath();
                canvas_context.arc(thumbX + this.height / 2, this.y + this.height / 2, this.height / 2, 0, Math.PI * 2);
                canvas_context.fill();
            }
        
            isPointInside(point) {
                return (
                    point.x >= this.x &&
                    point.x <= this.x + this.width &&
                    point.y >= this.y &&
                    point.y <= this.y + this.height
                );
            }
        
            handlePointer(point) {
            }
            handlePoint(point) {
                if (this.isPointInside(point)) {
                    this.state  *= -1;
                    if (this.onChange) {
                        this.onChange(this.state);
                    }
                }
            }
        }
        
    
    
    
    
        class Slider {
            constructor(x, y, width, min, max, initial, onChange) {
                this.x = x - 465;
                if(x == 760){
                  this.x-=24
                }
                this.y = y;
                this.width = width*.75;
                this.min = min;
                this.max = max;
                this.value = initial;
                this.onChange = onChange; // Callback when value changes
            }
        
            draw(label) {
                // Draw label
                canvas_context.fillStyle = '#FFF';
                canvas_context.font = '12px Arial';
                canvas_context.fillText(label, this.x, this.y - 6);
            
                // Draw track
                canvas_context.fillStyle = '#af0';
                canvas_context.fillRect(this.x, this.y, this.width, 10);
            
                // Draw thumb
                const ratio = (this.value - this.min) / (this.max - this.min);
                const thumbX = this.x + ratio * this.width - 5;
                canvas_context.fillStyle = '#f00';
                canvas_context.fillRect(thumbX+5, this.y - 5, 2, 20);
            
                // Draw value readout
                canvas_context.fillStyle = '#FFF';
                canvas_context.font = '14px Arial';
                if(Math.abs(this.value) >= .01){
                    canvas_context.fillText(this.value.toFixed(2), this.x + this.width + 10, this.y + 9);
                }else{
                    if(Math.abs(this.value) >= .001){
                    canvas_context.fillText(this.value.toFixed(3), this.x + this.width + 10, this.y + 9);
                    }else{
                    canvas_context.fillText(this.value.toFixed(4), this.x + this.width + 10, this.y + 9);
                    }
                }
            }
        
            isPointInside(point) {
                return (
                    point.x >= this.x &&
                    point.x <= this.x + this.width &&
                    point.y >= this.y - 10 &&
                    point.y <= this.y + 20
                );
            }
        
            handlePointer(point) {
                if (this.isPointInside(point)) {
                    const relativeX = point.x - this.x;
                    const ratio = Math.min(1, Math.max(0, relativeX / this.width));
                    const newValue = this.min + ratio * (this.max - this.min);
                    this.value = newValue;
                    if (this.onChange) {
                        this.onChange(this.value);
                    }
                }
            }
        
            handlePoint(point) {
                if (this.isPointInside(point)) {
                    const relativeX = point.x - this.x;
                    const ratio = Math.min(1, Math.max(0, relativeX / this.width));
                    const newValue = this.min + ratio * (this.max - this.min);
                    this.value = newValue;
                    if (this.onChange) {
                        this.onChange(this.value);
                    }
                }
            }
        }
    
        class HotSlider {
          constructor(x, y, width, min, max, initial, onChange) {
              this.x = x - 280;
              this.y = y;
              this.width = width;
              this.min = min;
              this.max = max;
              this.value = initial;
              this.onChange = onChange; // Callback when value changes
          }
      
          draw(label) {
              // Draw label
              canvas_context.fillStyle = '#FFF';
              canvas_context.font = '14px Arial';
              canvas_context.fillText(label, this.x, this.y - 6);
          
              // Draw track
              canvas_context.fillStyle = '#FF0';
              canvas_context.fillRect(this.x, this.y, this.width, 20);
          
              // Draw thumb
              const ratio = (this.value - this.min) / (this.max - this.min);
              const thumbX = this.x + ratio * this.width - 5;
              canvas_context.fillStyle = '#f00';
              canvas_context.fillRect(thumbX+5, this.y - 5, 4, 30);
          
              // Draw value readout
              canvas_context.fillStyle = '#FFF';
              canvas_context.font = '14px Arial';
              // if(Math.abs(this.value) >= .01){
              //     canvas_context.fillText(this.value.toFixed(2), this.x + this.width + 10, this.y + 9);
              // }else{
              //     if(Math.abs(this.value) >= .001){
              //     canvas_context.fillText(this.value.toFixed(3), this.x + this.width + 10, this.y + 9);
              //     }else{
              //     canvas_context.fillText(this.value.toFixed(4), this.x + this.width + 10, this.y + 9);
              //     }
              // }
          }
      
          isPointInside(point) {
              return (
                  point.x >= this.x &&
                  point.x <= this.x + this.width &&
                  point.y >= this.y - 10 &&
                  point.y <= this.y + 20
              );
          }
      
          handlePointer(point) {
              if (this.isPointInside(point)) {
                  const relativeX = point.x - this.x;
                  const ratio = Math.min(1, Math.max(0, relativeX / this.width));
                  const newValue = this.min + ratio * (this.max - this.min);
                  this.value = newValue;
                  if (this.onChange) {
                      this.onChange(this.value);
                  }
              }
          }
      
          handlePoint(point) {
              if (this.isPointInside(point)) {
                  const relativeX = point.x - this.x;
                  const ratio = Math.min(1, Math.max(0, relativeX / this.width));
                  const newValue = this.min + ratio * (this.max - this.min);
                  this.value = newValue;
                  if (this.onChange) {
                      this.onChange(this.value);
                  }
              }
          }
      }
    
        
        function adjustMovementCost(input){
            movementCost = input
        }
        function adjustEnergyGeneration(input){
            generationConstant = input
        }
        function adjustbaseCostOfNode(input){
            baseCostOfNode = input
        }
        function adjustmouthCost(input){
            mouthCost = input
        }
        function adjustdragCost(input){
            dragcost = input
        }
        function adjustanchorCost(input){
            anchorcost = input
        }
        function adjustpistonCost(input){
            pistoncost = input
        }
        function adjustrotationCost(input){
            rotationCost = input
        }
        function adjustmagnetCost(input){
            magnetcost = input
        }
        function adjustgenelengthcost(input){
            genelengthcost = input
        }
        function adjustlinkcostdistance(input){
            linkcostdistance = input
        }
        function adjustlinkcost(input){
            linkcost = input
        }
    
        
        function adjustlongevitycost(input){
            longevitycost = input
        }
        function adjustfertilitycost(input){
            fertilitycost = input
        }
        function adjustTemperature(input){
            temperature = input
        }
        function adjustmagnetradius(input){
            magnetradius = input
        }
        function adjustspeciesdistance(input){
            speciesdistance = input
        }
        function adjustrepconstant(input){
            repconstant = input
        }
        function adjustminage(input){
            minage = input
        }
        function adjustmaxage(input){
            maxage = input
        }
        function adjustloutmin(input){
            loutmin = input
        }
        function adjustcodonconstant(input){
            codonconstant = input
        }
        function adjustgenelength(input){
            genelength = input
        }
        function adjustworldscale(input){
            worldscale = input
        }
        function adjustpredatorIncentive(input){
            predatorIncentive = input
        }
        function adjustdriftconstant(input){
            driftconstant = input
        }
        function adjustdriftdistance(input){
            diffdist = input
        }
        function adjusttimemin(input){
            timemin = input
        }
        function adjustcodonusage(input){
            codonusage = input
        }
        function adjustparticletoggle(input){
            particletoggle = input
        }
        function adjustmutationrate(input){
            mutationrate = input
        }
        function adjustedgeLoop(input){
            edgeLoop = input
        }
        
        
        
        
          let looptext = "no loop"
          let edgebutt = new Rectangle(350, 200, 80, 40, "yellow")
          class NodeUI {
            constructor(){
    
    
                this.sliders = []
                this.sliderlabels = []
    
                this.sliders.push(new Slider(600, 60, 100, -.5, .5, movementCost, adjustMovementCost))
                this.sliderlabels.push("Movement Cost") 
                this.sliders.push(new Slider(600, 100, 100, -1, 1, generationConstant, adjustEnergyGeneration))
                this.sliderlabels.push("Energy Production")
                this.sliders.push(new Slider(600, 140, 100, -.1, .1, baseCostOfNode, adjustbaseCostOfNode))
                this.sliderlabels.push("Base Node Cost")
                this.sliders.push(new Slider(600, 180, 100, -.5, .5, mouthCost, adjustmouthCost))
                this.sliderlabels.push("Mouth Cost")
                this.sliders.push(new Slider(600, 220, 100, -.5, .5, dragcost, adjustdragCost))
                this.sliderlabels.push("Disease Cost")
                this.sliders.push(new Slider(600, 260, 100, -.5, .5, anchorcost, adjustanchorCost))
                this.sliderlabels.push("Anchor Cost")
                this.sliders.push(new Slider(600, 300, 100, -.5, .5, pistoncost, adjustpistonCost))
                this.sliderlabels.push("Piston Cost")
                this.sliders.push(new Slider(600, 340, 100, -.5, .5, rotationCost, adjustrotationCost))
                this.sliderlabels.push("Rotor Cost")
                this.sliders.push(new Slider(600, 380, 100, -.5, .5, magnetcost, adjustmagnetCost))
                this.sliderlabels.push("Magnetism Cost")
                this.sliders.push(new Slider(600, 420, 100, -.05, .05, genelengthcost, adjustgenelengthcost))
                this.sliderlabels.push("Gene Cost")
                this.sliders.push(new Slider(600, 460, 100, -.1, .1, linkcostdistance, adjustlinkcostdistance))
                this.sliderlabels.push("Link Length Cost")
                this.sliders.push(new Slider(600, 500, 100, -2, 2, fertilitycost, adjustfertilitycost))
                this.sliderlabels.push("Fertility Cost")
                this.sliders.push(new Slider(600, 540, 100, -2, 2, longevitycost, adjustlongevitycost))
                this.sliderlabels.push("Longevity Cost")
                this.sliders.push(new Slider(760, 300, 100, 0, 500, temperature, adjustTemperature))
                this.sliderlabels.push("Temperature")
                this.sliders.push(new Slider(760, 340, 100, 0, 50, magnetradius, adjustmagnetradius))
                this.sliderlabels.push("Magnet Radius Factor")
                this.sliders.push(new Slider(600, 580, 100, 0, 32*7, speciesdistance, adjustspeciesdistance))
                this.sliderlabels.push("Cannibal Range Factor")
                this.sliders.push(new Slider(760, 60, 100, 25, 500, repconstant, adjustrepconstant))
                this.sliderlabels.push("Reproduction Cost")
                this.sliders.push(new Slider(760, 100, 100, 1, 100, minage, adjustminage))
                this.sliderlabels.push("Minimum Death Age")
                this.sliders.push(new Slider(760, 140, 100, 101, 1000, maxage, adjustmaxage))
                this.sliderlabels.push("Maximum Age Scalar")
                this.sliders.push(new Slider(760, 180, 100, 1, 25, loutmin, adjustloutmin))
                this.sliderlabels.push("Link Length Minimum")
                this.sliders.push(new Slider(760, 220, 100, 0, 5, codonconstant, adjustcodonconstant))
                this.sliderlabels.push("Codon Mutation Factor")
                this.sliders.push(new Slider(760, 260, 100, 1, 17, genelength, adjustgenelength))
                this.sliderlabels.push("Gene Codon Base Length")
                this.sliders.push(new Slider(760, 380, 100, 4, 16, worldscale, adjustworldscale))
                this.sliderlabels.push("World Scale")
                this.sliders.push(new Slider(760, 420, 100, 0, 250, predatorIncentive, adjustpredatorIncentive))
                this.sliderlabels.push("Predation Incentive")
                this.sliders.push(new Slider(760, 460, 100, 1, 2500, driftconstant, adjustdriftconstant))
                this.sliderlabels.push("Drift Force Constant")
                this.sliders.push(new Slider(760, 500, 100, -1, 30, diffdist, adjustdriftdistance))
                this.sliderlabels.push("Drift Distance")
                this.sliders.push(new Slider(760, 540, 100, -.5, .5, linkcost, adjustlinkcost))
                this.sliderlabels.push("Link Flat Cost")
                this.sliders.push(new Slider(760, 580, 100, 0, 20, timemin, adjusttimemin))
                this.sliderlabels.push("Life Extension Factor")
                this.sliders.push(new Toggle(200, 350,  codonusage, adjustcodonusage))
                this.sliderlabels.push("Codon Use")
                this.sliders.push(new Toggle(200, 400,  particletoggle, adjustparticletoggle))
                this.sliderlabels.push("Particles")
                this.sliders.push(new Toggle(200, 450,  edgeLoop, adjustedgeLoop))
                this.sliderlabels.push("Edge Loop")
                this.sliders.push(new HotSlider(300, 520, 100, 0, .11, mutationrate, adjustmutationrate))
                this.sliderlabels.push("Mutation Rate")
                
                
                this.buttons = []
                this.muttons = [ new Rectangle(50, 250, 80, 40, "green")]
    
                this.mutations = [ new Rectangle(200, 100, 40, 40, "yellow"), new Rectangle(250, 100, 40, 40, "orange"), ]
    
                
                for(let t = 0;t<nodetypes;t++){
                    let button = new Rectangle(10, 20+(30*t), 20,20, "white")
                    this.buttons.push(button)
                }
            }
            draw(){
                for(let t = 0;t<this.muttons.length;t++){
                    canvas_context.fillStyle = "green"
                    canvas_context.fillRect(this.muttons[t].x, this.muttons[t].y, this.muttons[t].width, this.muttons[t].height)
    
                    canvas_context.fillStyle = "white"
                    canvas_context.lineWidth = 1
                    canvas_context.strokeStyle = "black"
                    canvas_context.font = "14px arial"
                    canvas_context.strokeText("Start", this.muttons[t].x+20, this.muttons[t].y+25)
                    canvas_context.fillText("Start", this.muttons[t].x+20, this.muttons[t].y+25)
    
    
    
                }
                for(let t = 0;t<this.sliders.length;t++){
                    this.sliders[t].draw(this.sliderlabels[t])
                }
                // for(let t = 0;t<this.mutations.length;t++){
                //     canvas_context.fillStyle = this.mutations[t].color
                //     canvas_context.fillRect(this.mutations[t].x, this.mutations[t].y, this.mutations[t].width, this.mutations[t].height)
    
                // }
                for(let t = 0;t<this.buttons.length;t++){
                    canvas_context.fillStyle = "#444444"
                    canvas_context.fillRect(this.buttons[t].x, this.buttons[t].y, this.buttons[t].width, this.buttons[t].height)
    
                    this.x = this.buttons[t].x+10
                    this.y = this.buttons[t].y+10
    
                    this.type = t
                    if (this.type == 0) {
                        this.inert = 1
                        this.body = new Circle(this.x, this.y, 3, "#ffffff")
                    }
                    if (this.type == 1) {
                        this.rotor = 1
                        this.armor = 1
                        // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF00aa")
                        // this.body = new Circle(this.x, this.y, 3, "#AA0055")
                        this.body = new Polygon(this.x, this.y, 4, "#AA0055", 4, 0, 0, (0) + Math.PI)
                    }
                    if (this.type == 2) {
                        this.armor = 1
                        this.motor = 1
                        // this.body = new Circle(this.x, this.y, 4, "#FF8800")
                        // this.body = new Rectangle(this.x - 2, this.y - 2, 4, 4, "#FF8800")
                        this.body = new Polygon(this.x, this.y, 5, "#ffff00", 3, 0, 0, (0))
                    }
                    if (this.type == 3) {
                        this.rotor = 1
                        this.motor = 1
                        // this.body = new Circle(this.x, this.y, 3.5, "#8800ff")
    
                    this.body =new Polygon(this.x, this.y, 5, "#8800ff", 3, 0, 0, (0) + Math.PI)
                    }
                    if (this.type == 4) {
                        this.produce = 1
                        // this.body = new Circle(this.x, this.y, 4, "#00FF00")
                        this.body = new Polygon(this.x, this.y, 5, "#00FF00", 6, 0, 0, (0) + Math.PI)
                    }
                    if (this.type == 5) {
                        this.armor = 1
                        this.mouth = 1
                        // this.body = new Circle(this.x, this.y, 5, "#FF0000")
                        this.body = new Polygon(this.x, this.y, 5, "#FF0000", 5, 0, 0, (0) + Math.PI)
                    }
                    if (this.type == 6) {
                        this.armor = 1
                        this.body = new Polygon(this.x, this.y, 5, "#FF8800", 4, 0, 0, (0) + Math.PI)
                    }
                    if (this.type == 7) {
                        this.produce = 1
                        this.motor = 1
                        this.body = new Polygon(this.x, this.y, 5, "#00FFFF", 3, 0, 0, (0) )
                    }
                    if (this.type == 8) {
                        this.produce = 1
                        this.rotor = 1
                        this.body = new Polygon(this.x, this.y, 5, "#228844", 4, 0, 0, (0) )
                    }
                    if (this.type == 9) {
                        this.anchor = 1
                        this.body = new Polygon(this.x, this.y, 5, "#4499FF", 5, 0, 0, (0) )
                    }
                    if (this.type == 10) {
                        this.anchor = 1
                        this.rotor = 1
                        this.body = new Polygon(this.x, this.y, 5, "#AA5678", 4, 0, 0, (0) )
                    }
                    if (this.type == 11) {
                        this.piston = 1
                        this.inert = 1
                        this.body = new Polygon(this.x, this.y, 6, "#AAFFAA", 2, 0, 0, (0) )
                    }
                    if (this.type == 12) {
                        this.piston = 1
                        this.body = new Polygon(this.x, this.y, 6, "#AA8888", 2, 0, 0, (0) )
                    }
                    if (this.type == 13) {
                        this.fertile = 1
                        this.body = new Circle(this.x, this.y, 3.5, "#FF44bb")
                    }
                    if (this.type == 14) {
                        this.life = 1
                        this.body = new Polygon(this.x, this.y, 5, "#889900", 5, 0, 0, (0) )
                    }
                    if (this.type == 15) {
                        this.drag = 1
                        this.body = new Polygon(this.x, this.y, 4, "#543210", 6, 0, 0, (0) )
                    }
    
    
                if(viewStyle == 4 || viewStyle == 6 || viewStyle == 5 || viewStyle == 7){
                    this.subcolor = this.body.color
                    this.body.parent = this
                    this.parent = this
                }
    
    
    
                    this.body.type = this.type
                    this.body.draw()
                     
                }
            }
            subcheck(point){
    
                // if(edgebutt.isPointInside(point)){
    
                //     canvas_context.fillStyle = "white"
                //     canvas_context.lineWidth = 1
                //     canvas_context.strokeStyle = "black"
                //     canvas_context.font = "14px arial"
                //     canvas_context.strokeText("World Loop Toggle", point.x, point.y)
                //     canvas_context.fillText("World Loop Toggle", point.x, point.y)
                //     return
                // }
    
                for(let t = 0;t<this.muttons.length;t++){
                    this.x = this.muttons[t].x
                    this.y = this.muttons[t].y
                    this.width = this.muttons[t].width
                    this.height = this.muttons[t].height
        
                    if (point.x >= this.x) {
                        if (point.y >= this.y) {
                            if (point.x <= this.x + this.width) {
                                if (point.y <= this.y + this.height) {
                                    canvas_context.fillStyle = "white"
                                    canvas_context.lineWidth = 1
                                    canvas_context.strokeStyle = "black"
                                    canvas_context.font = "14px arial"
                                    canvas_context.strokeText("Start", point.x, point.y)
                                    canvas_context.fillText("Start", point.x, point.y)
                                }
                            }
                        }
                    }
        
                    }
    
                    // for(let t = 0;t<this.mutations.length;t++){
                    // this.x = this.mutations[t].x
                    // this.y = this.mutations[t].y
                    // this.width = this.mutations[t].width
                    // this.height = this.mutations[t].height
        
                    // if (point.x >= this.x) {
                    //     if (point.y >= this.y) {
                    //         if (point.x <= this.x + this.width) {
                    //             if (point.y <= this.y + this.height) {
                    //                 if(t == 0){
                    //                     canvas_context.fillStyle = "white"
                    //                     canvas_context.lineWidth = 1
                    //                     canvas_context.strokeStyle = "black"
                    //                     canvas_context.font = "14px arial"
                    //                     canvas_context.strokeText("Mutation Down", point.x, point.y)
                    //                     canvas_context.fillText("Mutation Down", point.x, point.y)
                    //                 }else{
    
                    //                     canvas_context.fillStyle = "white"
                    //                     canvas_context.lineWidth = 1
                    //                     canvas_context.strokeStyle = "black"
                    //                     canvas_context.font = "14px arial"
                    //                     canvas_context.strokeText("Mutation Up", point.x, point.y)
                    //                     canvas_context.fillText("Mutation Up", point.x, point.y)
                    //                 }
                    //             }
                    //         }
                    //     }
                    // }
        
                    // }
                
                for(let t = 0;t<this.buttons.length;t++){
                    this.x = this.buttons[t].x
                    this.y = this.buttons[t].y
                    this.width = this.buttons[t].width
                    this.height = this.buttons[t].height
                    ////////////////console.log(this)
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
                               
                        if(nodin1 == -1){
                            // nodein.push(t)
                            canvas_context.fillStyle = '#092909'
                            canvas_context.fillRect(point.x-10, point.y-15, canvas_context.measureText(instructions[t]).width+20, 20)
    
    
                            canvas_context.fillStyle = "white"
                            canvas_context.lineWidth = 1
                            canvas_context.strokeStyle = "black"
                            canvas_context.font = "14px arial"
                            canvas_context.strokeText(instructions[t], point.x, point.y)
                            canvas_context.fillText(instructions[t], point.x, point.y)
                            return
                        }
                            }
                        }
                    }
                }
                }
    
            }
            stupidCheck(point){
    
                for(let t = 0;t<this.sliders.length;t++){
    
                    this.sliders[t].handlePointer(point)
    
                }
            }
            check(point){
    
                if(edgebutt.isPointInside(point)){
                    edgeLoop*=-1
                    return
                }
    
                for(let t = 0;t<this.sliders.length;t++){
    
                    this.sliders[t].handlePoint(point)
    
                }
                for(let t = 0;t<this.muttons.length;t++){
                this.x = this.muttons[t].x
                this.y = this.muttons[t].y
                this.width = this.muttons[t].width
                this.height = this.muttons[t].height
    
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
                                signal = 1
                            }
                        }
                    }
                }
    
                }
    
    
    
                for(let t = 0;t<this.mutations.length;t++){
                    this.x = this.mutations[t].x
                    this.y = this.mutations[t].y
                    this.width = this.mutations[t].width
                    this.height = this.mutations[t].height
        
                    if (point.x >= this.x) {
                        if (point.y >= this.y) {
                            if (point.x <= this.x + this.width) {
                                if (point.y <= this.y + this.height) {
                                    if(t == 0){
                                        if(mutationrate > 0){
                                            if(mutationrate < .0101){
    
                                                mutationrate-=.001
                                            }else{
                                                mutationrate-=.01
                                            }
                                        }
                                    }else{
                                        if(mutationrate < .1){
                                            if(mutationrate < .01){
                                                mutationrate+=.001
                                            }else{
                                                mutationrate+=.01
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
        
                    }
                
    
    
                
                for(let t = 0;t<this.buttons.length;t++){
                    this.x = this.buttons[t].x
                    this.y = this.buttons[t].y
                    this.width = this.buttons[t].width
                    this.height = this.buttons[t].height
                    ////////////////console.log(this)
                if (point.x >= this.x) {
                    if (point.y >= this.y) {
                        if (point.x <= this.x + this.width) {
                            if (point.y <= this.y + this.height) {
                               
                        if(nodin1 == -1){
                            nodein.push(t)
                            return
                        }
                            }
                        }
                    }
                }
                }
    
            }
          }
        
          let UI = new NodeUI()
          
        let deadwash = 4
        let deadmax = 33
        
        function cleanDeadOut() {
            deadwash++
            if (deadwash == deadmax) {
                mindead = 0
                deadwash = 0
                // let marks = []
                // for (let t = globalnodes.length - 1; t >= 0; t--) {
                for (let t = 0; t<globalnodes.length; t++) {
                    // ////////////////console.log(globalnodes[t])
                    // if(typeof globalnodes[t] != "undefined"){
        
                    if (globalnodes[t].dead == 1) {
                        for (let k = 0; k < globalnodes.length; k++) {
                            // if(t != k){
        
                            //////////////console.log(t, globalnodes[t].id)
                            globalnodes[k].indexkill(t)
                            // }
                        }
                        globalnodes.splice(t, 1)
                        ////////////////console.log("")
                        // if(mindead > t){
                        //     mindead--
                        // }
                        t-- 
                        superclick--
                        // let con = [...globalnodes[t].dcon] 
                        // globalnodes[t] = new Circle(0,0,1)
                        // globalnodes[t].dead = 1
                        // globalnodes[t].superdead = 1
                        // globalnodes[t].dcon = [...con]
                    }
                    // }
                }
                for (let t = 0; t<globalnodes.length; t++) {
                    // ////////////////console.log(globalnodes[t])
                    // if(typeof globalnodes[t] != "undefined"){
        
                    if (globalnodes[t].dead == 1) {
                        for (let k = 0; k < globalnodes.length; k++) {
                            // if(t != k){
        
                            //////////////console.log(t, globalnodes[t].id)
                            globalnodes[k].indexkill(t)
                            // }
                        }
                        globalnodes.splice(t, 1)
                        ////////////////console.log("")
                        // if(mindead > t){
                        //     mindead--
                        // }
                        t-- 
                        superclick--
                        // let con = [...globalnodes[t].dcon] 
                        // globalnodes[t] = new Circle(0,0,1)
                        // globalnodes[t].dead = 1
                        // globalnodes[t].superdead = 1
                        // globalnodes[t].dcon = [...con]
                    }
                    // }
                }
                for (let t = 0; t<globalnodes.length; t++) {
                    // ////////////////console.log(globalnodes[t])
                    // if(typeof globalnodes[t] != "undefined"){
        
                    if (globalnodes[t].dead == 1) {
                        for (let k = 0; k < globalnodes.length; k++) {
                            // if(t != k){
        
                            //////////////console.log(t, globalnodes[t].id)
                            globalnodes[k].indexkill(t)
                            // }
                        }
                        globalnodes.splice(t, 1)
                        ////////////////console.log("")
                        // if(mindead > t){
                        //     mindead--
                        // }
                        t-- 
                        superclick--
                        // let con = [...globalnodes[t].dcon] 
                        // globalnodes[t] = new Circle(0,0,1)
                        // globalnodes[t].dead = 1
                        // globalnodes[t].superdead = 1
                        // globalnodes[t].dcon = [...con]
                    }
                    // }
                }
                for (let t = 0; t<globalnodes.length; t++) {
                    // ////////////////console.log(globalnodes[t])
                    // if(typeof globalnodes[t] != "undefined"){
        
                    if (globalnodes[t].dead == 1) {
                        for (let k = 0; k < globalnodes.length; k++) {
                            // if(t != k){
        
                            //////////////console.log(t, globalnodes[t].id)
                            globalnodes[k].indexkill(t)
                            // }
                        }
                        globalnodes.splice(t, 1)
                        ////////////////console.log("")
                        // if(mindead > t){
                        //     mindead--
                        // }
                        t-- 
                        superclick--
                        // let con = [...globalnodes[t].dcon] 
                        // globalnodes[t] = new Circle(0,0,1)
                        // globalnodes[t].dead = 1
                        // globalnodes[t].superdead = 1
                        // globalnodes[t].dcon = [...con]
                    }
                    // }
                }
    
                for (let t = 0; t<globalnodes.length; t++) {
                    globalnodes[t].id = t
                }
            }
        
        }
        
        let metrics = {}
        metrics.tick = 100
        metrics.time = 0
        metrics.species = []
        metrics.complexity = []
        metrics.mincomplexity = []
        metrics.maxcomplexity = []
        metrics.diversity = []
        metrics.nodepopulation = []
        metrics.population = []
        let metricsON = 0
    
        let nodecolors = ["#FFFFFF", "#AA0055", "#ffff00", "#8800ff", "#00FF00", "#FF0000", "#FF8800", "#00FFFF", "#228844", "#4499FF","#AA5678" ,"#AAFFAA", "#AA8888","#FF44bb","#889900","#543210"]
        nodecolors[100] = "#543210"
          let types = ["Structural Node", "Rotation Node", "Head Node", "Rotational Head Node", "Production Node", "Tooth Node", "Armor Node", "Production Motor Node",  "Production Rotor Node","Generator Anchor Node", "Armored Anchor Node", "Generator Piston Node", "Armored Piston Node","Reproduction Node",'Longevity Node', "Disease Node"]
       
    
          
          canvas_context.fillStyle= "black"
          canvas_context.fillRect(0,0,canvas.width,canvas.height)
          let pix = canvas_context.getImageData(0,0,canvas.width*.5, canvas.height*.5)
       
       
    
          let particles = []
    
          let geneChars = ["S","R","H","Q", "P", "T","A","M","W","N","L","O","X","+","#"]
    
    
          function geneToType(genestring){
    
    
    
    
    
    
            let chars = genestring.split('')
     
            let c = {}
            for(let k = 0;k<chars.length;k++){
                if(c[chars[k]]){
                    c[chars[k]]++
                }else{
                    c[chars[k]] = 1
                }
            }
    
            let keys = Object.keys(c)
    
            let art = []
            for(let t = 0;t<keys.length;t++){
                art.push([c[keys[t]], keys[t]])
            }
    
            art.sort((a,b) => a[0] > b[0] ? -1:1)
    
            let type = geneChars.indexOf(art[0][1])
    
            if(art[1]){
                if(art[0][0] == art[1][0]){
                    if(art[0][0] > 1){
    
                    }else{
                        return 15
                    }
                }
            }
    
     
            if(art.length > 1){
                // console.log(art, keys, c, genestring, type)
            }
    
            return type
          }
    
          function mutateGenes(genes){
    
    
            let chars = genes.split('')
    
    
    
    
    
            for(let t = 0;t<chars.length;t++){
                if(Math.random() < mutationrate*codonconstant){
                    chars[t] = geneChars[Math.floor(Math.random()*geneChars.length)]
                }
            }
                if(Math.random() < mutationrate*codonconstant){
                    if(chars.length > 1){
                        let t = Math.floor(Math.random()*chars.length)
                        chars.splice(t,1)
                    }
                }
    
            if(Math.random() < mutationrate*codonconstant){
                if(Math.random() < .5){
                if(Math.random() < .5){
                    chars.push(geneChars[Math.floor(Math.random()*geneChars.length)])
                }else{
                    chars.unshift(geneChars[Math.floor(Math.random()*geneChars.length)])
                }
                }else{
                    if(Math.random() < .5){
                    chars.push(chars[Math.floor(Math.random()*chars.length)])
                    }else{
                        chars.unshift(chars[Math.floor(Math.random()*chars.length)])
                    }
                }
            }
    
            let g = ''
    
            for(let t = 0;t<chars.length;t++){
                g+=chars[t]
            }
            return g
    
          }
    
    
    class X {
        constructor(x, y,color,size) {
            const angle = Math.PI / 4
            this.size = size
            this.x = x
            this.y = y
            this.point1 = new Point(x + (Math.cos(angle) * this.size), y + (Math.sin(angle) * this.size))
            this.point2 = new Point(x + (Math.cos(angle) * -this.size), y + (Math.sin(angle) * -this.size))
            this.point3 = new Point(x + (Math.cos(angle + Math.PI * .5) * this.size), y + (Math.sin(angle + Math.PI * .5) * this.size))
            this.point4 = new Point(x + (Math.cos(angle + Math.PI * .5) * -this.size), y + (Math.sin(angle + Math.PI * .5) * -this.size))
            this.link1 = new LineOP(this.point1, this.point2, color, 2)
            this.link2 = new LineOP(this.point3, this.point4, color, 2)
            this.color = color
        }
        draw(angler) {
            this.angle = angler
            const angle = Math.PI / 4
            this.point1.x = this.x + (Math.cos(angle+this.angle) * this.size)
            this.point1.y = this.y + (Math.sin(angle+this.angle) * this.size)
            this.point2.x = this.x + (Math.cos(angle+this.angle) * -this.size)
            this.point2.y = this.y + (Math.sin(angle+this.angle) * -this.size)
            this.point3.x = this.x + (Math.cos(angle+this.angle+(Math.PI*.5)) * this.size)
            this.point3.y = this.y + (Math.sin(angle+this.angle+(Math.PI*.5)) * this.size)
            this.point4.x = this.x + (Math.cos(angle+this.angle+(Math.PI*.5)) * -this.size)
            this.point4.y = this.y + (Math.sin(angle+this.angle+(Math.PI*.5)) * -this.size)
    
    
            // console.log(this)
    
            this.link1.color = this.color
            this.link2.color = this.color
            if(start == 1){
    
                this.link1.width  = 3*worldscaler
                this.link2.width  = 3*worldscaler
            }else{
    
            this.link1.width  = 3
            this.link2.width  = 3
            }
            this.link1.draw()
            this.link2.draw()
        }
    }
    
    
    
    
    function resizeCanvas() {
        timerresize = 1000
      }
      window.addEventListener('resize', resizeCanvas);
    
    
    
      function DupeNoRef(node){
    
        let json = {}
        json.hold = []
    
    
        for(let t = 0;t<node.immune.length;t++){
            let n = globalnodes[node.immune[t]]
            let nud = new Node(n.x, n.y, n.type, n.genestring, 1)
    
            let keys = Object.keys(node)
            for(let h = 0;h<keys.length;h++ ){
                if(keys[h] != "link"){
    
                    nud[keys[h]] = node[keys[h]]
                }else[
                    console.log('S')
                ]
            }
    
            // delete nud.link
    
    
            let s = JSON.stringify(nud)
            json.hold.push(s)
        }
    
    
    
        console.log(json)
    
    
      }
    
    
    
       
          function main() { 
    
    
            for(let t = 0;t<globalnodes.length;t++){
                if(globalnodes[t].lockon == 1){
                    globalnodes[t].x = ((TIP_engine.x/2)) - (globalnodes[t].xavg-globalnodes[t].x)//- globalnodes[t].xavg)-globalnodes[t].x
                    globalnodes[t].y = ((TIP_engine.y/2)) - (globalnodes[t].yavg-globalnodes[t].y)// - globalnodes[t].yavg)-globalnodes[t].y
                    
                    if(keysPressed['d']){
                        globalnodes[t].energy+=1000000
                        keysPressed['d']= false
                    }
                    if(keysPressed['x']){
                        globalnodes[t].dead = 1
                    }
                }
            }
    
    
    
            worldscaler = worldscale/8
            // timerresize++
            if(timerresize%100 == 0){
                timerresize = 1
                canvas.width = document.documentElement.clientWidth;
                canvas.height = document.documentElement.clientHeight;
    
            }
            if(keysPressed['n']){
                magnetonly*=-1
                keysPressed['n'] = false
            }
    
            // if(keysPressed['y']){
            //     magnetzoom = 1
            //     keysPressed['y'] = false
            // }
            if(keysPressed['5']){
                magnetzoom = -1
                keysPressed['5'] = false
            }
    
            rotatick++
            // console.log(rotatick)
            if(rotatick >= rotaspeed){
                rotatick = 0
                rota++
                // console.log(rota)
                if(rota%rotaclickover == 0){
                    viewrota.sort((a,b)=>Math.random() >.5?1:-1)
                }
            }
    
    
    
            if(keysPressed['s']){
                slide *= -1
    
                keysPressed['s'] = false
            }
    
            if(keysPressed['t']){
                viewStyle = 1
                for(let t = 0;t<globalnodes.length;t++){
                    globalnodes[t].firsty = 0
                }
            }
            if(keysPressed['k']){
                viewStyle = 0
                for(let t = 0;t<globalnodes.length;t++){
                    globalnodes[t].firsty = 0
                }
            }
            if(keysPressed['0']){
                viewStyle = 6
                for(let t = 0;t<globalnodes.length;t++){
                    globalnodes[t].firsty = 0
                }
            }
            if(keysPressed['1']){
                viewStyle = 7
                for(let t = 0;t<globalnodes.length;t++){
                    globalnodes[t].firsty = 0
                }
            }
            if(keysPressed['u']){
                viewStyle = 2
                for(let t = 0;t<globalnodes.length;t++){
                    globalnodes[t].firsty = 0
                }
            }
            // if(keysPressed['f']){
            //     viewStyle = 3
            //     canvas_context.fillStyle= "black"
            //     canvas_context.fillRect(0,0,canvas.width,canvas.height)
            //     for(let t = 0;t<globalnodes.length;t++){
            //         globalnodes[t].firsty = 0
            //     }
            // }
            if(keysPressed['j']){
                viewStyle = 4
                for(let t = 0;t<globalnodes.length;t++){
                    globalnodes[t].firsty = 0
                }
            }
            if(keysPressed['a']){
                viewStyle = 5
                for(let t = 0;t<globalnodes.length;t++){
                    globalnodes[t].firsty = 0
                }
            }
            if(keysPressed['q']){
                metricsON = 1
            }
            if(keysPressed['V']){
                metricsON = 0
            }
            if(keysPressed['W']){
                let metrics = {}
                metrics.tick = 100
                metrics.time = 0
                metrics.species = []
                metrics.complexity = []
                metrics.mincomplexity = []
                metrics.maxcomplexity = []
                metrics.diversity = []
                metrics.nodepopulation = []
                metrics.population = []
            }
            if(fded != fded2 && fded2 < 0){
                if(signal == 1){
                    return
                }
            }
    
    
            bodc = 0
                canvas_context.font = "10px arial"
            canvas_context.fillStyle= "black"
            if(viewStyle != 3){
    
    
          if(slide == 1){
    
            canvas_context.fillStyle= "#00000020"
            canvas_context.putImageData(pix,0,0)
            canvas_context.fillRect(0,0,canvas.width,canvas.height)
    
          }else{
            canvas_context.fillRect(0, 0, canvas.width, canvas.height)
    
          }
            }
    
            if(start == 0){
    
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = "14px arial"
                canvas_context.strokeText("Pick two or more nodes for a seed organism and click start. Organisms need a production node (green).", 10, 12)
                canvas_context.fillText("Pick two or more nodes for a seed organism and click start. Organisms need a production node (green).", 10, 12)
    
                canvas_context.strokeText("Mutation Rate: "+(Math.round(mutationrate*10000)/100)+"%" , 10, 575+(-15))
                canvas_context.fillText("Mutation Rate: "+(Math.round(mutationrate*10000)/100)+"%" ,  10, 575+(-15))
                // canvas_context.fillText("Nodes:", 300, 300+(-15))
                canvas_context.strokeText("H can be used to see energy levels, E for age, R for complexity.", 10, 552+60)
                canvas_context.fillText("H can be used to see energy levels, E for age, R for complexity.", 10, 552+60)
    
    
                canvas_context.strokeText("A, T, U, J, 1, 0, 2 and K are different visualization modes.", 10, 582+60)
                canvas_context.fillText("A, T, U, J, 1, 0, 2 and K are different visualization modes.", 10, 582+60)
                canvas_context.strokeText("Use 6 to pick up an organism. With 6 held, D to dupe, X to kill.", 10, 612+60)
                canvas_context.fillText("Use 6 to pick up an organism. With 6 held, D to dupe, X to kill.", 10, 612+60)
                canvas_context.strokeText("O/P are for speed control.", 10, 642+60)
                canvas_context.fillText("O/P are for speed control.", 10, 642+60)
    
                
    
                canvas_context.fillStyle = "white"
                canvas_context.lineWidth = 1
                canvas_context.strokeStyle = "black"
                canvas_context.font = "15px arial"
    
                canvas_context.strokeText("Chosen Nodes:", 45, 750+(-16))
                canvas_context.fillText("Chosen Nodes:", 45, 750+(-16))
                for(let t = 0;t<nodein.length;t++){
    
    
                  canvas_context.fillStyle = nodecolors[[nodein[t]]]
                  
                    canvas_context.strokeText(types[nodein[t]], 45, 750+(t*16))
                    canvas_context.fillText(types[nodein[t]], 45, 750+(t*16))
        
        
                }
    
    
                // edgebutt.draw()
                // if(edgeLoop != 1){
                //     looptext = "no loop"
                //     edgebutt.color = "Yellow"
                // }else{
                //     looptext = "loop"
                //     edgebutt.color = "white"
                // }
                canvas_context.strokeStyle = "black"
                canvas_context.font = "14px arial"
                // canvas_context.fillText(looptext, edgebutt.x+20, edgebutt.y+20)
    
                
                UI.draw()
                UI.subcheck(TIP_engine)
    
    
    
    
                if(signal == 1){
                    if(nodein.length >= 2){
                        init(nodein)
                        start = 1
                    }else{
                        signal = 0
                    }
                }else{
    
                }
                return
            }
    
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].freeenergy()
            }
            
            
    
            
            ld = 0
            seenToday = {}
        
            let mindead = 0
            let lock = 0
            for (let t = 0; t < globalnodes.length; t++) {
    
                if(globalnodes[t].dead == 1){
                    if(lock == 0){
                        // mindead = t
                    }
                    continue
                }
                lock = 1
                globalnodes[t].time()
            }
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                globalnodes[t].drive()
            }
    
            
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                globalnodes[t].link.mark = 0
                globalnodes[t].link.list = []
    
            }
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                globalnodes[t].push()
            }
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                globalnodes[t].makeRotation()
            }
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                globalnodes[t].makePiston()
            }
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                globalnodes[t].makeLink()
            }
    
    
    
            for (let t = mindead; t < globalnodes.length; t++) {
            globalnodes[t].x += globalnodes[t].xleap
            globalnodes[t].y += globalnodes[t].yleap
    
            globalnodes[t].xleap = 0
            globalnodes[t].yleap = 0
            }
    
            cleanDeadOut()
    
            for(let t = 0;t<globduper.length;t++){
    
                let node 
                if(codonusage == 1){
    
                     node = new Node(globduper[t].x, globduper[t].y, geneToType(globduper[t].genestring), globduper[t].genestring)
                }else{
                     node = new Node(globduper[t].x, globduper[t].y, globduper[t].type, globduper[t].genestring)
                }
                node.head = 0
                node.radio = globduper[t].radio
                node.extra = globduper[t].extra
                node.charge = globduper[t].charge
                node.magratio = globduper[t].magratio
                // if(globalnodes[globduper[t].linkto].cut != 1){
                //console.log(globduper[t].linkto)
                    node.connect(globalnodes[globduper[t].linkto])
                // }
            }
            globduper = []
            macrodupe= 0
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                globalnodes[t].make()
            }
            // let worldscaler = worldscale/8
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                if (globalnodes[t].link.mark == 1) {
                    for (let r = 0; r < globalnodes[t].link.list.length; r++) {
                        if(globalnodes[globalnodes[t].link.list[r]].dead != 1 && globalnodes[t].dead != 1){
    
                            //////////////console.log(globalnodes[t].link.list[r])
                            globalnodes[t].link.target = globalnodes[globalnodes[t].link.list[r]]
                            globalnodes[t].link.width = 2*worldscaler
                            globalnodes[t].link.color =`rgb(${128+ (.5*globalnodes[(globalnodes[t].shead)].r)},${128+ (.5*globalnodes[(globalnodes[t].shead)].g)},${128+ (.5*globalnodes[(globalnodes[t].shead)].b)})`
                            if(magnetonly == 1){
    
                            }else{
    
                                globalnodes[t].link.draw()
                            }
                        }
                    }
                }
            }
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                globalnodes[t].drawBody()
            }
    
    
            if(magnetism > 0){
            
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                if(globalnodes[t].age < minage){
                    // continue
                }
                if(globalnodes[t].dead ==1){
                    continue
                }
                for (let k = mindead; k < globalnodes.length; k++) {
    
                    if(globalnodes[t].charge != 0){
                        if(globalnodes[k].charge != 0){
                    globalnodes[t].link.target = globalnodes[k]
                    let mes = globalnodes[t].link.hypotenuse() 
    
                        // let d = globalnodes[t].magnet.radius+globalnodes[k].magnet.radius
    
                        let m = globalnodes[t].magnet.radius+globalnodes[k].magnet.radius
                    if(mes < m){
                        let a = globalnodes[t].link.angle()
                        let rat = ((m-(mes))/((m)))+magmax
    
                                if(globalnodes[t].charge != globalnodes[k].charge){
    
    
                                    if(globalnodes[t].anchor != 1){
                                    globalnodes[t].x -= Math.cos(a) * .5 * rat * worldscaler
                                    globalnodes[t].y -= Math.sin(a) * .5* rat* worldscaler
                                    }
    
                                    if(globalnodes[k].anchor != 1){
                                    globalnodes[k].x += Math.cos(a) * .5* rat* worldscaler
                                    globalnodes[k].y += Math.sin(a) * .5* rat* worldscaler
                                    }
    
    
                                }else{
    
                                    if(globalnodes[t].anchor != 1){
                                        globalnodes[t].x += Math.cos(a) * .5* rat* worldscaler
                                        globalnodes[t].y += Math.sin(a) * .5* rat* worldscaler
                                    }
    
    
                                    if(globalnodes[k].anchor != 1){
                                    globalnodes[k].x -= Math.cos(a) * .5* rat* worldscaler
                                    globalnodes[k].y -= Math.sin(a) * .5* rat* worldscaler
                                    }
                                }
                            }
                        }
    
                    }
                }
            }
    
        }
    
    
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                if(globalnodes[t].age < minage){
                    // continue
                }
                if(globalnodes[t].dead ==1){
                    continue
                }
                for (let k = mindead; k < globalnodes.length; k++) {
                    if(t == k){ //new????
                        continue
                    }
                    if(globalnodes[k].dead ==1){
                        continue
                    }
                    let x = Math.abs(globalnodes[k].x - globalnodes[t].x) 
                    let y = Math.abs(globalnodes[k].y - globalnodes[t].y) 

                    let matta = (worldscale*1.25)-(worldscale*.05)
                    if(x > matta || y> matta ){
                        continue
                    }
                    // if(x > 10){
                        if(x < (diffdist*worldscaler) && y < (diffdist*worldscaler)){
                            let z = globalnodes[k].x - globalnodes[t].x
                            if( (!(globalnodes[t].link.target.immune.includes(t)))){ 
                                if(globalnodes[k].anchor != 1){
                                    globalnodes[k].x += ((z/diffdist)/driftconstant)*worldscaler
                                }
                                if(globalnodes[t].anchor != 1){
                            globalnodes[t].x -= ((z/diffdist)/driftconstant)*worldscaler
                                }
                            }
                        }
    
                    // if(Math.abs(globalnodes[k].y - globalnodes[t].y) > 10){
                     
                    if(x < (diffdist*worldscaler) && y < (diffdist*worldscaler)){
                            let z = globalnodes[k].y - globalnodes[t].y
                            if( (!(globalnodes[t].link.target.immune.includes(t)))){
                                if(globalnodes[k].anchor != 1){
                            globalnodes[k].y += ((z/diffdist)/driftconstant)*worldscaler
                                }
    
                                if(globalnodes[t].anchor != 1){
                            globalnodes[t].y -= ((z/diffdist)/driftconstant)*worldscaler
                                }
                            }
                        }
                        // continue
                    // }
    
    
                    if((globalnodes[k].age < minage || globalnodes[t].age < minage) && globalnodes[k].age!=globalnodes[t].age){
    
                        globalnodes[t].link.target = globalnodes[k]
    
                        let j = 0
                        let mes = globalnodes[t].link.hypotenuse()
                        let a = globalnodes[t].link.angle()
                        while (mes < (worldscale*1.125) && !(globalnodes[t].link.target.stupidimmune[t] == 1)) {
                            j++
                            if(j>20){
                                break
                            }
                            // let a = globalnodes[t].link.angle()
                            globalnodes[t].x += Math.cos(a) * 2
                            globalnodes[t].y += Math.sin(a) * 2
                            globalnodes[t].link.target.x -= Math.cos(a) * 2
                            mes += 4
                        }
    
                        
                        continue
                    }
    
                    
                    if (t != k) {
                        globalnodes[t].link.target = globalnodes[k]
                        let j = 0
    
                        let mes = globalnodes[t].link.hypotenuse() 
                        let a = globalnodes[t].link.angle()
    
    
    
    
    
                        while (mes <= worldscale) {      //(Math.max(globalnodes[t].link.target.lout,globalnodes[t].lout))-1
                            j++
                            if(j>20){
                                break
                            }
                    
                            let colorsmack  =0 
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].r-globalnodes[globalnodes[t].link.target.shead].r)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].g-globalnodes[globalnodes[t].link.target.shead].g)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].b-globalnodes[globalnodes[t].link.target.shead].b)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].p-globalnodes[globalnodes[t].link.target.shead].p)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].z-globalnodes[globalnodes[t].link.target.shead].q)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].q-globalnodes[globalnodes[t].link.target.shead].z)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].m-globalnodes[globalnodes[t].link.target.shead].m)
    
                            if(globalnodes[t].mouth == 1  && colorsmack > speciesdistance &&  globalnodes[t].link.target.armor != 1 &&    (!(globalnodes[t].link.target.immune.includes(t)))){
                                if(globalnodes[t].neighbors.includes(k)){
                                    
                                }else{
    
    
                                    if((globalnodes[t].dead != 1 && globalnodes[t].link.target.dead!=1)    && (globalnodes[t].trueage > minage && globalnodes[t].link.target.trueage > minage)){
    
                                        globalnodes[t].energy += (globalnodes[t].link.target.energy*(globalnodes[t].link.target.immune.length/2))+predatorIncentive
                                        globalnodes[t].age -= (globalnodes[t].link.target.energy*(globalnodes[t].link.target.immune.length/2))+predatorIncentive
                                        globalnodes[t].link.target.energy = 0
                                        globalnodes[t].age = Math.max(globalnodes[t].age, minage)
                                        globalnodes[t].energy = Math.min(globalnodes[t].energy, globalnodes[t].gencap)
                                        globalnodes[t].link.target.dead = 1
                                        if(totalKill == 1){
                                            for(let d = 0;d<globalnodes[t].link.target.immune.length;d++){
                                                globalnodes[globalnodes[t].link.target.immune[d]].dead = 1
                                            }
                                        }
                                        for(let r = 0;r<globalnodes[t].link.target.neighbors.length;r++){
                                            // globalnodes[t].link.target.disconnect(globalnodes[globalnodes[t].link.target.neighbors[r]])
                                        }
                                    }
                                }
                            }
                            if(globalnodes[t].link.target.mouth == 1  && colorsmack > speciesdistance && globalnodes[t].armor != 1 &&  (!(globalnodes[t].immune.includes(k)))){
                                if(globalnodes[t].link.target.neighbors.includes(t)){
                                    
                                }else{
                                    if((globalnodes[t].dead != 1 && globalnodes[t].link.target.dead!=1)    && (globalnodes[t].trueage > minage && globalnodes[t].link.target.trueage > minage)){
                                        globalnodes[t].link.target.energy += (globalnodes[t].energy*(globalnodes[t].immune.length/2))+predatorIncentive
                                        globalnodes[t].link.target.age -= (globalnodes[t].energy*(globalnodes[t].immune.length/2))+predatorIncentive
                                        globalnodes[t].energy = 0
                                        globalnodes[t].link.target.age = Math.max(globalnodes[t].link.target.age, minage)
                                        globalnodes[t].link.target.energy = Math.min(globalnodes[t].link.target.energy, globalnodes[t].link.target.gencap)
                                        globalnodes[t].dead = 1
                                        if(totalKill == 1){ 
                                        for(let d = 0;d<globalnodes[t].immune.length;d++){
                                            globalnodes[globalnodes[t].immune[d]].dead = 1
                                        }
                                    }
                                        for(let r = 0;r<globalnodes[t].neighbors.length;r++){
                                            // globalnodes[t].disconnect(globalnodes[globalnodes[t].neighbors[r]])
                                        }
                                    }
                                }
                            }
        
                            // let a = globalnodes[t].link.angle()
                   
                            if(true){
    
                                let outs = 0
                                if(globalnodes[t].anchor != 1 || globalnodes[t].link.target.anchor == 1){
                                    globalnodes[t].x += Math.cos(a) * .5 * worldscaler
                                    globalnodes[t].y += Math.sin(a) * .5 * worldscaler
    
                                    outs+=.5 * worldscaler
                                }else{
                                    globalnodes[t].x += Math.cos(a) * .005 * worldscaler
                                    globalnodes[t].y += Math.sin(a) * .005 * worldscaler
                                    outs+=.005 * worldscaler
                                }
                                if(globalnodes[t].motor == 1){
                                    if(globalnodes[t].link.target.anchor != 1 || globalnodes[t].anchor == 1){
                                        globalnodes[t].link.target.x -= Math.cos(a) * 1 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * 1 * worldscaler
                                        outs+=1 * worldscaler
                                    }else{
                                        globalnodes[t].link.target.x -= Math.cos(a) * .01 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * .01 * worldscaler
                                        outs+=.01 * worldscaler
                                    }
                                    mes += 1.5
                                }else{
                                    if(globalnodes[t].link.target.anchor != 1 || globalnodes[t].anchor == 1){
                                        globalnodes[t].link.target.x -= Math.cos(a) * .5 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * .5 * worldscaler
                                        outs+=.5 * worldscaler
                                    }else{
                                        globalnodes[t].link.target.x -= Math.cos(a) * .005 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * .005 * worldscaler
                                        outs+=.005 * worldscaler
                                    }
                                    mes+=outs
        
        
                                }
                            }
                            if( !globalnodes[t].immune.includes(k)){
                                // if( !globalnodes[k].link.list.includes(t)){
                                let spin = (Math.random()-.5)/3
                                globalnodes[t].pushout+=spin
                                globalnodes[t].link.target.pushout-=spin
                                globalnodes[t].pushoutsto = globalnodes[t].pushout
                                globalnodes[t].link.target.pushout = globalnodes[t].link.target.pushout
                                // }
                            }
                        }
    
                        if (mes <=(worldscale*1.25)-(worldscale*.05)) {      
    
    
                            let colorsmack  =0 
                            // colorsmack  = colordistance(globalnodes[globalnodes[t].shead], globalnodes[globalnodes[t].link.target.shead])
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].r-globalnodes[globalnodes[t].link.target.shead].r)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].g-globalnodes[globalnodes[t].link.target.shead].g)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].b-globalnodes[globalnodes[t].link.target.shead].b)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].p-globalnodes[globalnodes[t].link.target.shead].p)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].z-globalnodes[globalnodes[t].link.target.shead].q)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].q-globalnodes[globalnodes[t].link.target.shead].z)
                            colorsmack += Math.abs(globalnodes[globalnodes[t].shead].m-globalnodes[globalnodes[t].link.target.shead].m)
    
    
                            if(globalnodes[t].mouth == 1  && colorsmack > speciesdistance &&  globalnodes[t].link.target.armor != 1 &&    (!(globalnodes[t].link.target.immune.includes(t)))){
                                if(globalnodes[t].neighbors.includes(k)){
                                    
                                }else{
    
    
                                    if((globalnodes[t].dead != 1 && globalnodes[t].link.target.dead!=1)    && (globalnodes[t].trueage > minage && globalnodes[t].link.target.trueage > minage)){
    
                                        globalnodes[t].energy += (globalnodes[t].link.target.energy*(globalnodes[t].link.target.immune.length/2))+predatorIncentive
                                        globalnodes[t].age -= (globalnodes[t].link.target.energy*(globalnodes[t].link.target.immune.length/2))+predatorIncentive
                                        globalnodes[t].link.target.energy = 0
                                        globalnodes[t].age = Math.max(globalnodes[t].age, minage)
                                        globalnodes[t].energy = Math.min(globalnodes[t].energy, globalnodes[t].gencap)
                                        globalnodes[t].link.target.dead = 1
                                        if(totalKill == 1){
                                            for(let d = 0;d<globalnodes[t].link.target.immune.length;d++){
                                                globalnodes[globalnodes[t].link.target.immune[d]].dead = 1
                                            }
                                        }
                                        for(let r = 0;r<globalnodes[t].link.target.neighbors.length;r++){
                                            // globalnodes[t].link.target.disconnect(globalnodes[globalnodes[t].link.target.neighbors[r]])
                                        }
                                    }
                                }
                            }
                            if(globalnodes[t].link.target.mouth == 1  && colorsmack > speciesdistance && globalnodes[t].armor != 1 &&  (!(globalnodes[t].immune.includes(k)))){
                                if(globalnodes[t].link.target.neighbors.includes(t)){
                                    
                                }else{
                                    if((globalnodes[t].dead != 1 && globalnodes[t].link.target.dead!=1)    && (globalnodes[t].trueage > minage && globalnodes[t].link.target.trueage > minage)){
                                        globalnodes[t].link.target.energy += (globalnodes[t].energy*(globalnodes[t].immune.length/2))+predatorIncentive
                                        globalnodes[t].link.target.age -= (globalnodes[t].energy*(globalnodes[t].immune.length/2))+predatorIncentive
                                        globalnodes[t].energy = 0
                                        globalnodes[t].link.target.age = Math.max(globalnodes[t].link.target.age, minage)
                                        globalnodes[t].link.target.energy = Math.min(globalnodes[t].link.target.energy, globalnodes[t].link.target.gencap)
                                        globalnodes[t].dead = 1
                                        if(totalKill == 1){ 
                                        for(let d = 0;d<globalnodes[t].immune.length;d++){
                                            globalnodes[globalnodes[t].immune[d]].dead = 1
                                        }
                                    }
                                        for(let r = 0;r<globalnodes[t].neighbors.length;r++){
                                            // globalnodes[t].disconnect(globalnodes[globalnodes[t].neighbors[r]])
                                        }
                                    }
                                }
                            }
        
    
                            
                            // let a = globalnodes[t].link.angle()
    
                            if(true){
    
                                let outs = 0
                                if(globalnodes[t].anchor != 1 || globalnodes[t].link.target.anchor == 1){
                                    globalnodes[t].x += Math.cos(a) * .5 * worldscaler
                                    globalnodes[t].y += Math.sin(a) * .5 * worldscaler
    
                                    outs+=.5 * worldscaler
                                }else{
                                    globalnodes[t].x += Math.cos(a) * .005 * worldscaler
                                    globalnodes[t].y += Math.sin(a) * .005 * worldscaler
                                    outs+=.005 * worldscaler
                                }
                                if(globalnodes[t].motor == 1){
                                    if(globalnodes[t].link.target.anchor != 1 || globalnodes[t].anchor == 1){
                                        globalnodes[t].link.target.x -= Math.cos(a) * 1 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * 1 * worldscaler
                                        outs+=1 * worldscaler
                                    }else{
                                        globalnodes[t].link.target.x -= Math.cos(a) * .01 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * .01 * worldscaler
                                        outs+=.01 * worldscaler
                                    }
                                    mes += 1.5
                                }else{
                                    if(globalnodes[t].link.target.anchor != 1 || globalnodes[t].anchor == 1){
                                        globalnodes[t].link.target.x -= Math.cos(a) * .5 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * .5 * worldscaler
                                        outs+=.5 * worldscaler
                                    }else{
                                        globalnodes[t].link.target.x -= Math.cos(a) * .005 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * .005 * worldscaler
                                        outs+=.005 * worldscaler
                                    }
                                    mes+=outs
        
        
                                }
                            }
    
                            if(true){
    
                                let outs = 0
                                if(globalnodes[t].anchor != 1 || globalnodes[t].link.target.anchor == 1){
                                    globalnodes[t].x += Math.cos(a) * .5 * worldscaler
                                    globalnodes[t].y += Math.sin(a) * .5 * worldscaler
    
                                    outs+=.5 * worldscaler
                                }else{
                                    globalnodes[t].x += Math.cos(a) * .005 * worldscaler
                                    globalnodes[t].y += Math.sin(a) * .005 * worldscaler
                                    outs+=.005 * worldscaler
                                }
                                if(globalnodes[t].motor == 1){
                                    if(globalnodes[t].link.target.anchor != 1 || globalnodes[t].anchor == 1){
                                        globalnodes[t].link.target.x -= Math.cos(a) * 1 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * 1 * worldscaler
                                        outs+=1 * worldscaler
                                    }else{
                                        globalnodes[t].link.target.x -= Math.cos(a) * .01 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * .01 * worldscaler
                                        outs+=.01 * worldscaler
                                    }
                                    mes += 1.5
                                }else{
                                    if(globalnodes[t].link.target.anchor != 1 || globalnodes[t].anchor == 1){
                                        globalnodes[t].link.target.x -= Math.cos(a) * .5 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * .5 * worldscaler
                                        outs+=.5 * worldscaler
                                    }else{
                                        globalnodes[t].link.target.x -= Math.cos(a) * .005 * worldscaler
                                        globalnodes[t].link.target.y -= Math.sin(a) * .005 * worldscaler
                                        outs+=.005 * worldscaler
                                    }
                                    mes+=outs
        
        
                                }
                            }
    
    
    
    
    
                            
                            if( !globalnodes[t].immune.includes(k)){
                                // if( !globalnodes[k].link.list.includes(t)){
                                let spin = (Math.random()-.5)/3
                                globalnodes[t].pushout+=spin
                                globalnodes[t].link.target.pushout-=spin
                                globalnodes[t].pushoutsto = globalnodes[t].pushout
                                globalnodes[t].link.target.pushout = globalnodes[t].link.target.pushout
                                // }
                            }
    
    
    
    
                        }
                    }
                }
            }
        
    
    
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                if(globalnodes[t].trueage > 5){
                    globalnodes[t].dying()
                }
            }
    
            if(particletoggle == 1 || ( particletoggle == 1 && (viewStyle == 6 || viewStyle == 7) && rotatick < (rotaspeed-14))){
    
                for(let t = 0;t<globalnodes.length;t++){
                    if(globalnodes[t].dead == 1){
                        if(globalnodes[t].ultradead != 1){
                            globalnodes[t].ultradead = 1
                            let spin = 5
                            for(let r = 0;r<spin;r++){
                                let a = (r*((Math.PI/(spin/2))))
                                let p = new Circle(globalnodes[t].x, globalnodes[t].y, 3.5*worldscaler, globalnodes[t].body.color, Math.cos(a)*.4*worldscaler, Math.sin(a)*.4*worldscaler)
                                p.shrink = 1
                                p.type = globalnodes[t].type
                                // if(viewStyle == 5 || viewStyle == 7 || viewStyle == 4 || viewStyle == 6){
                                    p.subcolor = globalnodes[t].subcolor
                                // }
                                particles.push(p)
                            }
        
                        }
                    }
                }
        
        
                for(let t = particles.length-1;t>=0;t--){
                    particles[t].move()
                    if(magnetonly == 1){
    
                    }else{
                        particles[t].draw()
                    }
                    particles[t].radius-=.25*worldscaler
                }
                for(let t = particles.length-1;t>=0;t--){
                    if(particles[t].radius <= 0){
                        particles.splice(t,1)
                    }
                }
            }
        
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].superhead = 0
            }
            for (let t = 0; t < globalnodes.length; t++) {
    
                // if(globalnodes[t].dead == 1){
                //     continue
                // }
                if(globalnodes[t].head == 1 && globalnodes[t].trueage > 2){
                    globalnodes[t].energyBalance()
                    globalnodes[t].superhead = 1
                    for(let f = 0;f<globalnodes.length;f++){
                        if(globalnodes[f].link.list.includes(t) == 1){
                            if(t != f){
                                globalnodes[f].head = 0
                                globalnodes[f].headkill = 1 ////??
                            }
                        }
                    }
    
    
                }
    
    
            }
            // if(deadwash < deadmax-3 && deadwash > 3){
    
            //     for (let t = 0; t < globalnodes.length; t++) {
    
            //         if(globalnodes[t].dead == 1){
            //             continue
            //         }
            //         if(globalnodes[t].head == 1 && globalnodes[t].trueage > 2){
        
            //             if(Math.random() < (mutationrate/10)){
            //                 globalnodes[t].head = 0
            //                 // console.log(globalnodes[t].immune[Math.floor(globalnodes[t].immune.length*Math.random())])
            //                 globalnodes[globalnodes[t].immune[Math.floor(globalnodes[t].immune.length*Math.random())]].head = 1
                        
            //             }
            //         }
        
        
            //     }
            // }
    
            if(viewStyle != 3){
    
                let link = new LineOP(new Point(TIP_engine.x/2, TIP_engine.y/2), TIP_engine)
                let min = 9999999999
                let inder = -1
                for (let t = mindead; t < globalnodes.length; t++) {
                    link.target = globalnodes[t]
                    globalnodes[t].talk = 0
                    if(!keysPressed['6']){
                        globlock=0
                    globalnodes[t].lockon =0
                    }
                    let h = link.hypotenuse()
                    if(h < min){
                        min = h
                        inder = t
                    }
                }
    
                if(inder != -1){
                    for(let t = 0;t<globalnodes[inder].immune.length;t++){
    
                        globalnodes[globalnodes[inder].immune[t]].talk = 1
                    
                    }
                }
    
    
    
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dead == 1){
                    continue
                }
                if(globalnodes[t].talk == 1 || !keysPressed['4']){
                    globalnodes[t].text()
                    if(keysPressed['6']){
                        if(globalnodes[t].talk){
                            if(globlock ==0){
    
                            globlock = 1
                            globalnodes[t].lockon = 1
                            for(let f = 0;f<globalnodes[t].immune.length;f++){
                                globalnodes[globalnodes[t].immune[f]].lockon = 1
                            }
                            }
                        }
                    }
                }
                if(keysPressed['4']){
                    if(globalnodes[t].talk == 1){
                        // DupeNoRef(globalnodes[t])
                    }
                }
                // if(globalnodes[t].die == 1){
                //     ////////////////console.log("hd")
                //     // globalnodes[t].dead = 1
                // }
            }
    
            }
            for (let t = mindead; t < globalnodes.length; t++) {
                if(globalnodes[t].dmark == 1){
                    globalnodes[t].superdead = 1
                }
            }
            
            let alldead = 0
            for(let t = 0;t<globalnodes.length;t++){
                if(globalnodes[t].dead ==1){
                    alldead++
                }
            }
    
            // canvas_context.fillText(globalnodes.length+" / "+alldead, 5,10)
            //////////////////////console.log(ld)
    
    
    
    
            if(viewStyle == 3){
    
            }else{
    
            if(slide == 1){
    
                pix = canvas_context.getImageData(0,0,canvas.width,canvas.height)
                canvas_context.drawImage(canvas,0,0,canvas.width, canvas.height, 0,0, canvas.width*2, canvas.height*2)
        
            }else{
                if(magnetzoom == 1){
    
                pix = canvas_context.getImageData(0,0,canvas.width/2,canvas.height/2)
    
                let d = pix.data
    
                let sampler = []
                let link = new LineOP(new Point(0,0),new Point(0,0))
        
        
                let tess = []
                for(let t = 0;t<d.length;t+=4){
                    tess.push(t)
        
                }
        
                tess.sort((a,b)=>Math.random()>.5?-1:1)
        
                for(let w = 0;w<d.length;w++){
                    let t = tess[w]
                    let rsum = 0
                    let gsum = 0
                    let bsum = 0
        
                   
                //    if(Math.random()<.1){
                //     sampler = {}
                //    }
                //    if(Math.random()<.2){
                    let p =  indexer(t, canvas.width/2)
                    link.object = p
    
                    for(let k = 0;k<globalnodes.length;k++){
                        // if(sampler[k]){
                        //     continue
                        // }
                        link.target = globalnodes[k]
                        if(globalnodes[k].charge == -1){ 
                            let h = link.squareDistance()
                            h/= Math.max(((globalnodes[k].magratio)*20)-1,1)
                            bsum+= 100/(h+1)
                            // rsum+= 100/(h+1)
                            // gsum-= 100/(h+1)
    
                            if(gsum > 0){
                                rsum+= Math.min(100/Math.max(h+.5,1),gsum)*1.55
                                gsum -= Math.min(100/Math.max(h+1,1),gsum)
                            }
    
    
                        }
                        if(globalnodes[k].charge == 1){
                            let h = link.squareDistance()
                            h/= Math.max((((globalnodes[k].magratio))*20)-1,1)
    
                            if(bsum > 0){
                                rsum+= Math.min(100/Math.max(h+.5,1),bsum)*1.55
                                bsum -= Math.min(100/Math.max(h+1,1),bsum)
                            }
    
    
                            gsum+= 100/(h+1)
                            // bsum-= 100/(h+1)
                        }
                        // if(h > 3600){
                        //     // sampler[k] = true
                        //     continue
                        // }
                        // rsum += Math.max((globalnodes[k].subr/(((h/65)+.1)/2)/2)-h,0)
                        // gsum +=  Math.max((globalnodes[k].subg/(((h/65)+.1)/2)/2)-h,0)
                        // bsum +=  Math.max((globalnodes[k].subb/(((h/65)+.1)/2)/2)-h,0)
                    }
                //    }
                    d[t] = rsum
                    d[t+1] =gsum
                    d[t+2] = bsum
                    d[t+3] = 255
                }
    
                canvas_context.putImageData(pix,0,0)
                }else{
    
    
                }
                canvas_context.drawImage(canvas,0,0,canvas.width, canvas.height, 0,0, canvas.width*2, canvas.height*2)
        
    
            }
        
    
            }
    
    
            if(viewStyle == 3){
                // canvas_context.drawImage(canvas,0,0,canvas.width, canvas.height, 0,0, canvas.width/2, canvas.height/2)
             
                let d = pix.data 
        
        
                let sampler = []
                let link = new LineOP(new Point(0,0),new Point(0,0))
        
        
                let tess = []
                for(let t = 0;t<d.length;t+=4){
                    tess.push(t)
        
                }
        
                tess.sort((a,b)=>Math.random()>.5?-1:1)
        
                for(let w = 0;w<d.length;w+=4){
                    let t = tess[w]
                    let rsum = 0
                    let gsum = 0
                    let bsum = 0
        
                   
                //    if(Math.random()<.1){
                //     sampler = {}
                //    }
                   if(Math.random()<.2){
                    let p =  indexer(t, canvas.width/2)
                    link.object = p
    
                    for(let k = 0;k<globalnodes.length;k++){
                        // if(sampler[k]){
                        //     continue
                        // }
                        link.target = globalnodes[k]
                        let h = link.squareDistance()
                        if(h > 3600){
                            // sampler[k] = true
                            continue
                        }
                        rsum += Math.max((globalnodes[k].subr/(((h/65)+.1)/2)/2)-h,0)
                        gsum +=  Math.max((globalnodes[k].subg/(((h/65)+.1)/2)/2)-h,0)
                        bsum +=  Math.max((globalnodes[k].subb/(((h/65)+.1)/2)/2)-h,0)
                    }
                   }
                    d[t] =  ((d[t]*12) +rsum)/13
                    d[t+1] = ((d[t+1]*12) +gsum)/13
                    d[t+2] = ((d[t+2]*12) +bsum)/13
                    d[t+3] = 255
                }
        
                canvas_context.putImageData(pix,0,0)
                for (let t = mindead; t < globalnodes.length; t++) {
                    if(globalnodes[t].dead == 1){
                        continue
                    }
                    globalnodes[t].text()
                    // if(globalnodes[t].die == 1){
                    //     ////////////////console.log("hd")
                    //     // globalnodes[t].dead = 1
                    // }
                }
                canvas_context.drawImage(canvas,0,0,canvas.width, canvas.height, 0,0, canvas.width*2, canvas.height*2)
         
            }
            //////////console.log(bodc, bodc-lsstbodc, globalnodes.length-lasfgl)
            // if(bodc-lsstbodc != globalnodes.length-lasfgl){
    
            // }else{
                fded = lsstbodc
                fded2 = lasfgl
                lsstbodc = bodc
                lasfgl = globalnodes.length
    
            for (let t = 0; t < globalnodes.length; t++) {
                globalnodes[t].aged()
            }
            // }
    
            // for (let t = 0; t < globalnodes.length; t++) {
            //     if(globalnodes[t].die == 1){
            //         globalnodes[t].dead = 1
            //         for (let k = 0; k < globalnodes.length; k++) {
            //             globalnodes[k].indexkill(t)
            //         }
            //     }
            // }
    
            if(metricsON == 1){
                metrics.time++
            }
            let buckets = {}
            if(metrics.time==metrics.tick){
                metrics.time = 0
                let comp = 0
                let compm = 0
                let min = 999999999999
                let max = 0
        
                for(let t = 0;t<globalnodes.length;t++){
                    // ////console.log(globalnodes[t].runprod)
                    if(globalnodes[t].head == 1 && globalnodes[t].dead != 1 && globalnodes[t].runprod > 0){
                        comp+=globalnodes[t].ll
                        min = Math.min(globalnodes[t].ll, min)
                        max = Math.max(globalnodes[t].ll, max)
                        compm++
                        if(buckets[globalnodes[t].runsum+','+globalnodes[t].runprod]){
                            buckets[globalnodes[t].runsum+','+globalnodes[t].runprod]++
                        }else{
                            buckets[globalnodes[t].runsum+','+globalnodes[t].runprod] = 1
                        }
                    }
                }
        
                comp/=compm
                if(true){
                let alldead = 0
                for(let t = 0;t<globalnodes.length;t++){
                    if(globalnodes[t].dead ==1){
                        alldead++
                    }
                }
                metrics.nodepopulation.push(globalnodes.length-alldead)
                }
                metrics.complexity.push(comp)
                metrics.mincomplexity.push(min)
                metrics.maxcomplexity.push(max)
                metrics.population.push(compm)
                metrics.species.push(buckets)
    
                // let outdiv = 0
                // let divsum = 0
                // let divtotsum = 0
                // let keys = Object.keys(buckets)
                // for(let r = 0;r<keys.length;r++){
                //     divsum++
                //     divtotsum+=buckets[keys[r]]
                // }
    
                
                // outdiv = divsum/divtotsum
    
    
                metrics.diversity.push(dindex(buckets))
    
    
    
    
    
            }
            if(keysPressed['q']){
                console.log(metrics)
            }
    
            
        }
        
        // })
    
    
        function dindex(speciesCounts) {
            const species = Object.keys(speciesCounts);
            const N = species.reduce((sum, key) => sum + speciesCounts[key], 0);
            if (N <= 1) return 0; 
            let sum = 0;
            for (const key of species) {
              const n = speciesCounts[key];
              sum += (n * (n - 1));
            }
            const D = sum / (N * (N - 1));
            const simpsonsIndex = 1 - D;
            return simpsonsIndex;
          }
    
    
          function indexer(index, width) {
            const pixelIndex = index / 4; // Each pixel takes up 4 values: R, G, B, A
            const x = pixelIndex % width;
            const y = Math.floor(pixelIndex / width);
            return { x, y };
          }
    
    
    
    
          let odds = 0
    
          let total = 0
          let found = 0
          let given = 10000000
    
          function generateGene(){
    
            let g = ''
            for(let t =0 ;t<genelength;t++){
                g += geneChars[Math.floor(Math.random()*geneChars.length)]
            }
    
            // console.log(g)
            return g
          }
    
        //   for(let t = 0;t<given;t++){
        
        //     if(geneToType(generateGene()) == 15){
    
        //         found++
    
        //     }
        //   }
        //   odds = found/given
        //   console.log(odds)
          
    
    </script>
  </div>
</ul>
</div>

 

</html>
